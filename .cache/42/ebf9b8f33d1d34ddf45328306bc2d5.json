{"id":"node_modules/@aws-amplify/pubsub/lib/Providers/AWSAppSyncProvider.js","dependencies":[{"name":"C:\\home\\auth-kampo\\node_modules\\@aws-amplify\\pubsub\\lib\\Providers\\AWSAppSyncProvider.js.map","includedInParent":true,"mtime":1557861850000},{"name":"C:\\home\\auth-kampo\\node_modules\\@aws-amplify\\pubsub\\src\\Providers\\AWSAppSyncProvider.ts","includedInParent":true,"mtime":1557861739000},{"name":"C:\\home\\auth-kampo\\node_modules\\@aws-amplify\\pubsub\\package.json","includedInParent":true,"mtime":1560308010595},{"name":"zen-observable","loc":{"line":57,"column":25},"parent":"C:\\home\\auth-kampo\\node_modules\\@aws-amplify\\pubsub\\lib\\Providers\\AWSAppSyncProvider.js","resolved":"C:\\home\\auth-kampo\\node_modules\\zen-observable\\index.js"},{"name":"@aws-amplify/core","loc":{"line":58,"column":21},"parent":"C:\\home\\auth-kampo\\node_modules\\@aws-amplify\\pubsub\\lib\\Providers\\AWSAppSyncProvider.js","resolved":"C:\\home\\auth-kampo\\node_modules\\@aws-amplify\\core\\lib\\index.js"},{"name":"./MqttOverWSProvider","loc":{"line":59,"column":35},"parent":"C:\\home\\auth-kampo\\node_modules\\@aws-amplify\\pubsub\\lib\\Providers\\AWSAppSyncProvider.js","resolved":"C:\\home\\auth-kampo\\node_modules\\@aws-amplify\\pubsub\\lib\\Providers\\MqttOverWSProvider.js"}],"generated":{"js":"\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\n            t[p[i]] = s[p[i]];\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Observable = require(\"zen-observable\");\nvar core_1 = require(\"@aws-amplify/core\");\nvar MqttOverWSProvider_1 = require(\"./MqttOverWSProvider\");\nvar logger = new core_1.ConsoleLogger('AWSAppSyncProvider');\nvar AWSAppSyncProvider = /** @class */ (function (_super) {\n    __extends(AWSAppSyncProvider, _super);\n    function AWSAppSyncProvider() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this._topicClient = new Map();\n        _this._topicAlias = new Map();\n        return _this;\n    }\n    Object.defineProperty(AWSAppSyncProvider.prototype, \"endpoint\", {\n        get: function () { throw new Error('Not supported'); },\n        enumerable: true,\n        configurable: true\n    });\n    AWSAppSyncProvider.prototype.getProviderName = function () { return 'AWSAppSyncProvider'; };\n    AWSAppSyncProvider.prototype.publish = function (topics, msg, options) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                throw new Error('Operation not supported');\n            });\n        });\n    };\n    AWSAppSyncProvider.prototype._cleanUp = function (clientId) {\n        var _this = this;\n        var topicsForClient = Array.from(this._topicClient.entries())\n            .filter(function (_a) {\n            var c = _a[1];\n            return c.clientId === clientId;\n        })\n            .map(function (_a) {\n            var t = _a[0];\n            return t;\n        });\n        topicsForClient.forEach(function (t) { return _this._cleanUpForTopic(t); });\n    };\n    AWSAppSyncProvider.prototype._cleanUpForTopic = function (topic) {\n        this._topicClient.delete(topic);\n        this._topicAlias.delete(topic);\n    };\n    AWSAppSyncProvider.prototype.onDisconnect = function (_a) {\n        var _this = this;\n        var clientId = _a.clientId, errorCode = _a.errorCode, args = __rest(_a, [\"clientId\", \"errorCode\"]);\n        if (errorCode !== 0) {\n            var topicsForClient = Array.from(this._topicClient.entries())\n                .filter(function (_a) {\n                var c = _a[1];\n                return c.clientId === clientId;\n            })\n                .map(function (_a) {\n                var t = _a[0];\n                return t;\n            });\n            topicsForClient.forEach(function (topic) {\n                if (_this._topicObservers.has(topic)) {\n                    _this._topicObservers.get(topic).forEach(function (obs) {\n                        if (!obs.closed) {\n                            obs.error(args);\n                        }\n                    });\n                    _this._topicObservers.delete(topic);\n                }\n            });\n            this._cleanUp(clientId);\n        }\n    };\n    AWSAppSyncProvider.prototype.disconnect = function (clientId) {\n        return __awaiter(this, void 0, void 0, function () {\n            var client;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.clientsQueue.get(clientId, function () { return null; })];\n                    case 1:\n                        client = _a.sent();\n                        return [4 /*yield*/, _super.prototype.disconnect.call(this, clientId)];\n                    case 2:\n                        _a.sent();\n                        this._cleanUp(clientId);\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    AWSAppSyncProvider.prototype.subscribe = function (topics, options) {\n        var _this = this;\n        if (options === void 0) { options = {}; }\n        var result = new Observable(function (observer) {\n            var targetTopics = [].concat(topics);\n            logger.debug('Subscribing to topic(s)', targetTopics.join(','));\n            (function () { return __awaiter(_this, void 0, void 0, function () {\n                var _a, mqttConnections, newSubscriptions, newAliases, map;\n                var _this = this;\n                return __generator(this, function (_b) {\n                    switch (_b.label) {\n                        case 0:\n                            // Add these topics to map\n                            targetTopics.forEach(function (t) {\n                                if (!_this._topicObservers.has(t)) {\n                                    _this._topicObservers.set(t, new Set());\n                                }\n                                _this._topicObservers.get(t).add(observer);\n                            });\n                            _a = options.mqttConnections, mqttConnections = _a === void 0 ? [] : _a, newSubscriptions = options.newSubscriptions;\n                            newAliases = Object.entries(newSubscriptions)\n                                .map(function (_a) {\n                                var alias = _a[0], v = _a[1];\n                                return [v.topic, alias];\n                            });\n                            // Merge new aliases with old ones\n                            this._topicAlias = new Map(Array.from(this._topicAlias.entries()).concat(newAliases));\n                            map = Object.entries(targetTopics.reduce(function (acc, elem) {\n                                var connectionInfoForTopic = mqttConnections.find(function (c) { return c.topics.indexOf(elem) > -1; });\n                                if (connectionInfoForTopic) {\n                                    var clientId = connectionInfoForTopic.client, url = connectionInfoForTopic.url;\n                                    if (!acc[clientId]) {\n                                        acc[clientId] = {\n                                            url: url,\n                                            topics: new Set(),\n                                        };\n                                    }\n                                    acc[clientId].topics.add(elem);\n                                }\n                                return acc;\n                            }, {}));\n                            // reconnect everything we have in the map\n                            return [4 /*yield*/, Promise.all(map.map(function (_a) {\n                                    var clientId = _a[0], _b = _a[1], url = _b.url, topics = _b.topics;\n                                    return __awaiter(_this, void 0, void 0, function () {\n                                        var client;\n                                        var _this = this;\n                                        return __generator(this, function (_c) {\n                                            switch (_c.label) {\n                                                case 0: return [4 /*yield*/, this.connect(clientId, {\n                                                        clientId: clientId,\n                                                        url: url,\n                                                    })];\n                                                case 1:\n                                                    client = _c.sent();\n                                                    // subscribe to all topics for this client\n                                                    // store topic-client mapping\n                                                    topics.forEach(function (topic) {\n                                                        if (client.isConnected()) {\n                                                            client.subscribe(topic);\n                                                            _this._topicClient.set(topic, client);\n                                                        }\n                                                    });\n                                                    return [2 /*return*/, client];\n                                            }\n                                        });\n                                    });\n                                }))];\n                        case 1:\n                            // reconnect everything we have in the map\n                            _b.sent();\n                            return [2 /*return*/];\n                    }\n                });\n            }); })();\n            return function () {\n                logger.debug('Unsubscribing from topic(s)', targetTopics.join(','));\n                targetTopics.forEach(function (t) {\n                    var client = _this._topicClient.get(t);\n                    if (client && client.isConnected()) {\n                        client.unsubscribe(t);\n                        _this._topicClient.delete(t);\n                        if (!Array.from(_this._topicClient.values()).some(function (c) { return c === client; })) {\n                            _this.disconnect(client.clientId);\n                        }\n                    }\n                    _this._topicObservers.delete(t);\n                });\n            };\n        });\n        return Observable.from(result).map(function (value) {\n            var topic = _this.getTopicForValue(value);\n            var alias = _this._topicAlias.get(topic);\n            value.data = Object.entries(value.data)\n                .reduce(function (obj, _a) {\n                var origKey = _a[0], val = _a[1];\n                return (obj[(alias || origKey)] = val, obj);\n            }, {});\n            return value;\n        });\n    };\n    return AWSAppSyncProvider;\n}(MqttOverWSProvider_1.MqttOverWSProvider));\nexports.AWSAppSyncProvider = AWSAppSyncProvider;\n"},"sourceMaps":{"js":{"version":3,"file":"AWSAppSyncProvider.js","sourceRoot":"","sources":["../../src/Providers/AWSAppSyncProvider.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright 2017-2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"). You may not use this file except in compliance with\n * the License. A copy of the License is located at\n *\n *     http://aws.amazon.com/apache2.0/\n *\n * or in the \"license\" file accompanying this file. This file is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions\n * and limitations under the License.\n */\nimport { Client } from 'paho-mqtt';\nimport * as Observable from 'zen-observable';\nimport { ConsoleLogger as Logger } from '@aws-amplify/core';\n\nimport { MqttOverWSProvider } from './MqttOverWSProvider';\n\nconst logger = new Logger('AWSAppSyncProvider');\n\nexport class AWSAppSyncProvider extends MqttOverWSProvider {\n\n    protected get endpoint() { throw new Error('Not supported'); }\n\n    getProviderName() { return 'AWSAppSyncProvider'; }\n\n    public async publish(topics: string[] | string, msg: any, options?: any) {\n        throw new Error('Operation not supported');\n    }\n\n    private _cleanUp(clientId: string) {\n        const topicsForClient = Array.from(this._topicClient.entries())\n            .filter(([, c]) => c.clientId === clientId)\n            .map(([t]) => t);\n\n        topicsForClient.forEach(t => this._cleanUpForTopic(t));\n    }\n\n    private _cleanUpForTopic(topic) {\n        this._topicClient.delete(topic);\n        this._topicAlias.delete(topic);\n    }\n\n    public onDisconnect({ clientId, errorCode, ...args }) {\n        if (errorCode !== 0) {\n            const topicsForClient = Array.from(this._topicClient.entries())\n                .filter(([, c]) => c.clientId === clientId)\n                .map(([t,]) => t);\n\n            topicsForClient.forEach(topic => {\n                if (this._topicObservers.has(topic)) {\n                    this._topicObservers.get(topic).forEach(obs => {\n                        if (!obs.closed) {\n                            obs.error(args);\n                        }\n                    });\n\n                    this._topicObservers.delete(topic);\n                }\n            });\n\n            this._cleanUp(clientId);\n        }\n    }\n\n    private _topicClient: Map<string, Client> = new Map();\n\n    private _topicAlias: Map<string, string> = new Map();\n\n    protected async disconnect(clientId: string): Promise<void> {\n        const client = await this.clientsQueue.get(clientId, () => null);\n\n        await super.disconnect(clientId);\n\n        this._cleanUp(clientId);\n    }\n\n    subscribe(topics: string[] | string, options: any = {}): Observable<any> {\n\n        const result = new Observable<any>(observer => {\n            const targetTopics = ([] as string[]).concat(topics);\n            logger.debug('Subscribing to topic(s)', targetTopics.join(','));\n\n            (async () => {\n                // Add these topics to map\n                targetTopics.forEach(t => {\n                    if (!this._topicObservers.has(t)) {\n                        this._topicObservers.set(t, new Set());\n                    }\n\n                    this._topicObservers.get(t).add(observer);\n                });\n\n                const { mqttConnections = [], newSubscriptions } = options;\n\n                // creates a map of {\"topic\": \"alias\"}\n                const newAliases = Object.entries(newSubscriptions)\n                    .map(([alias, v]: [string, { topic: string }]) => [v.topic, alias]);\n\n                // Merge new aliases with old ones\n                this._topicAlias = new Map([\n                    ...Array.from(this._topicAlias.entries()),\n                    ...(newAliases as [string, string][])\n                ]);\n\n                // group by urls\n                const map: [string, { url: string, topics: Set<string> }][] = Object.entries(targetTopics.reduce(\n                    (acc, elem) => {\n                        const connectionInfoForTopic = mqttConnections.find(c => c.topics.indexOf(elem) > -1);\n\n                        if (connectionInfoForTopic) {\n                            const { client: clientId, url } = connectionInfoForTopic;\n\n                            if (!acc[clientId]) {\n                                acc[clientId] = {\n                                    url,\n                                    topics: new Set(),\n                                };\n                            }\n\n                            acc[clientId].topics.add(elem);\n                        }\n\n                        return acc;\n                    },\n                    {}\n                ));\n\n                // reconnect everything we have in the map\n                await Promise.all(map.map(async ([clientId, { url, topics }]) => {\n                    // connect to new client\n                    const client = await this.connect(clientId, {\n                        clientId,\n                        url,\n                    });\n\n                    // subscribe to all topics for this client\n                    // store topic-client mapping\n                    topics.forEach(topic => {\n                        if (client.isConnected()) {\n                            client.subscribe(topic);\n\n                            this._topicClient.set(topic, client);\n                        }\n                    });\n\n                    return client;\n                }));\n            })();\n\n            return () => {\n                logger.debug('Unsubscribing from topic(s)', targetTopics.join(','));\n\n                targetTopics.forEach(t => {\n                    const client = this._topicClient.get(t);\n\n                    if (client && client.isConnected()) {\n                        client.unsubscribe(t);\n                        this._topicClient.delete(t);\n\n                        if (!Array.from(this._topicClient.values()).some(c => c === client)) {\n                            this.disconnect(client.clientId);\n                        }\n                    }\n\n                    this._topicObservers.delete(t);\n                });\n            };\n        });\n\n        return Observable.from(result).map(value => {\n            const topic = this.getTopicForValue(value);\n            const alias = this._topicAlias.get(topic);\n\n            value.data = Object.entries(value.data)\n                .reduce((obj, [origKey, val]) => (obj[((alias || origKey) as string)] = val, obj), {});\n\n            return value;\n        });\n    }\n}\n"]}},"error":null,"hash":"d3f1ad88a6ef29133d59be8898628d82","cacheData":{"env":{}}}