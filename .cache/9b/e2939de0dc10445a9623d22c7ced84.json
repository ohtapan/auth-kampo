{"id":"node_modules/@aws-amplify/analytics/lib/Providers/AWSPinpointProvider.js","dependencies":[{"name":"C:\\Users\\太田遥人\\Desktop\\auth-kampo\\node_modules\\@aws-amplify\\analytics\\lib\\Providers\\AWSPinpointProvider.js.map","includedInParent":true,"mtime":1557861886000},{"name":"C:\\Users\\太田遥人\\Desktop\\auth-kampo\\node_modules\\@aws-amplify\\analytics\\src\\Providers\\AWSPinpointProvider.ts","includedInParent":true,"mtime":1557861738000},{"name":"C:\\Users\\太田遥人\\Desktop\\auth-kampo\\node_modules\\@aws-amplify\\analytics\\package.json","includedInParent":true,"mtime":1560308010598},{"name":"@aws-amplify/core","loc":{"line":67,"column":21},"parent":"C:\\Users\\太田遥人\\Desktop\\auth-kampo\\node_modules\\@aws-amplify\\analytics\\lib\\Providers\\AWSPinpointProvider.js","resolved":"C:\\Users\\太田遥人\\Desktop\\auth-kampo\\node_modules\\@aws-amplify\\core\\lib\\index.js"},{"name":"aws-sdk/clients/mobileanalytics","loc":{"line":68,"column":30},"parent":"C:\\Users\\太田遥人\\Desktop\\auth-kampo\\node_modules\\@aws-amplify\\analytics\\lib\\Providers\\AWSPinpointProvider.js","resolved":"C:\\Users\\太田遥人\\Desktop\\auth-kampo\\node_modules\\aws-sdk\\clients\\mobileanalytics.js"},{"name":"aws-sdk/clients/pinpoint","loc":{"line":69,"column":23},"parent":"C:\\Users\\太田遥人\\Desktop\\auth-kampo\\node_modules\\@aws-amplify\\analytics\\lib\\Providers\\AWSPinpointProvider.js","resolved":"C:\\Users\\太田遥人\\Desktop\\auth-kampo\\node_modules\\aws-sdk\\clients\\pinpoint.js"},{"name":"@aws-amplify/cache","loc":{"line":70,"column":22},"parent":"C:\\Users\\太田遥人\\Desktop\\auth-kampo\\node_modules\\@aws-amplify\\analytics\\lib\\Providers\\AWSPinpointProvider.js","resolved":"C:\\Users\\太田遥人\\Desktop\\auth-kampo\\node_modules\\@aws-amplify\\cache\\lib\\index.js"},{"name":"uuid","loc":{"line":71,"column":21},"parent":"C:\\Users\\太田遥人\\Desktop\\auth-kampo\\node_modules\\@aws-amplify\\analytics\\lib\\Providers\\AWSPinpointProvider.js","resolved":"C:\\Users\\太田遥人\\Desktop\\auth-kampo\\node_modules\\uuid\\index.js"}],"generated":{"js":"\"use strict\";\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\n            t[p[i]] = s[p[i]];\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/*\n * Copyright 2017-2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"). You may not use this file except in compliance with\n * the License. A copy of the License is located at\n *\n *     http://aws.amazon.com/apache2.0/\n *\n * or in the \"license\" file accompanying this file. This file is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions\n * and limitations under the License.\n */\nvar core_1 = require(\"@aws-amplify/core\");\nvar MobileAnalytics = require(\"aws-sdk/clients/mobileanalytics\");\nvar Pinpoint = require(\"aws-sdk/clients/pinpoint\");\nvar cache_1 = require(\"@aws-amplify/cache\");\nvar uuid_1 = require(\"uuid\");\nvar AMPLIFY_SYMBOL = ((typeof Symbol !== 'undefined' && typeof Symbol.for === 'function') ?\n    Symbol.for('amplify_default') : '@@amplify_default');\nvar dispatchAnalyticsEvent = function (event, data) {\n    core_1.Hub.dispatch('analytics', { event: event, data: data }, 'Analytics', AMPLIFY_SYMBOL);\n};\nvar logger = new core_1.ConsoleLogger('AWSPinpointProvider');\nvar NON_RETRYABLE_EXCEPTIONS = ['BadRequestException', 'SerializationException', 'ValidationException'];\n// events buffer\nvar BUFFER_SIZE = 1000;\nvar FLUSH_SIZE = 100;\nvar FLUSH_INTERVAL = 5 * 1000; // 5s\nvar RESEND_LIMIT = 5;\n// params: { event: {name: , .... }, timeStamp, config, resendLimits }\nvar AWSPinpointProvider = /** @class */ (function () {\n    function AWSPinpointProvider(config) {\n        this._endpointGenerating = true;\n        this._buffer = [];\n        this._config = config ? config : {};\n        this._config.bufferSize = this._config.bufferSize || BUFFER_SIZE;\n        this._config.flushSize = this._config.flushSize || FLUSH_SIZE;\n        this._config.flushInterval = this._config.flushInterval || FLUSH_INTERVAL;\n        this._config.resendLimit = this._config.resendLimit || RESEND_LIMIT;\n        this._clientInfo = core_1.ClientDevice.clientInfo();\n    }\n    AWSPinpointProvider.prototype._setupTimer = function () {\n        var _this = this;\n        if (this._timer) {\n            clearInterval(this._timer);\n        }\n        var _a = this._config, flushSize = _a.flushSize, flushInterval = _a.flushInterval;\n        var that = this;\n        this._timer = setInterval(function () {\n            var size = _this._buffer.length < flushSize ? _this._buffer.length : flushSize;\n            for (var i = 0; i < size; i += 1) {\n                var params = _this._buffer.shift();\n                that._sendFromBuffer(params);\n                // If this is the first request sent by Analytics module, we should stop sending remaining requests\n                // to prevent race condition of updating one endpoint when it's being created in the backend\n                if (_this._endpointGenerating)\n                    break;\n            }\n        }, flushInterval);\n    };\n    /**\n     * @private\n     * @param params - params for the event recording\n     * Put events into buffer\n     */\n    AWSPinpointProvider.prototype._putToBuffer = function (params) {\n        var bufferSize = this._config.bufferSize;\n        if (this._buffer.length < bufferSize) {\n            this._buffer.push(params);\n            return Promise.resolve(true);\n        }\n        else {\n            logger.debug('exceed analytics events buffer size');\n            return Promise.reject(false);\n        }\n    };\n    AWSPinpointProvider.prototype._sendFromBuffer = function (params) {\n        return __awaiter(this, void 0, void 0, function () {\n            var event, config, appId, region, resendLimit, success, _a;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        event = params.event, config = params.config;\n                        appId = config.appId, region = config.region, resendLimit = config.resendLimit;\n                        success = true;\n                        _a = event.name;\n                        switch (_a) {\n                            case '_session.start': return [3 /*break*/, 1];\n                            case '_session.stop': return [3 /*break*/, 3];\n                            case '_update_endpoint': return [3 /*break*/, 5];\n                        }\n                        return [3 /*break*/, 7];\n                    case 1: return [4 /*yield*/, this._startSession(params)];\n                    case 2:\n                        success = _b.sent();\n                        return [3 /*break*/, 9];\n                    case 3: return [4 /*yield*/, this._stopSession(params)];\n                    case 4:\n                        success = _b.sent();\n                        return [3 /*break*/, 9];\n                    case 5: return [4 /*yield*/, this._updateEndpoint(params)];\n                    case 6:\n                        success = _b.sent();\n                        return [3 /*break*/, 9];\n                    case 7: return [4 /*yield*/, this._recordCustomEvent(params)];\n                    case 8:\n                        success = _b.sent();\n                        return [3 /*break*/, 9];\n                    case 9:\n                        if (!success) {\n                            params.resendLimits = typeof params.resendLimits === 'number' ?\n                                params.resendLimits : resendLimit;\n                            if (params.resendLimits > 0) {\n                                logger.debug(\"resending event \" + params.eventName + \" with \" + params.resendLimits + \" retry times left\");\n                                params.resendLimits -= 1;\n                                this._putToBuffer(params);\n                            }\n                            else {\n                                logger.debug(\"retry times used up for event \" + params.eventName);\n                            }\n                        }\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * get the category of the plugin\n     */\n    AWSPinpointProvider.prototype.getCategory = function () {\n        return AWSPinpointProvider.category;\n    };\n    /**\n     * get provider name of the plugin\n     */\n    AWSPinpointProvider.prototype.getProviderName = function () {\n        return AWSPinpointProvider.providerName;\n    };\n    /**\n     * configure the plugin\n     * @param {Object} config - configuration\n     */\n    AWSPinpointProvider.prototype.configure = function (config) {\n        var _this = this;\n        logger.debug('configure Analytics', config);\n        var conf = config ? config : {};\n        this._config = Object.assign({}, this._config, conf);\n        if (this._config['appId'] && !this._config['disabled']) {\n            if (!this._config['endpointId']) {\n                var cacheKey = this.getProviderName() + '_' + this._config['appId'];\n                this._getEndpointId(cacheKey).then(function (endpointId) {\n                    logger.debug('setting endpoint id from the cache', endpointId);\n                    _this._config['endpointId'] = endpointId;\n                    dispatchAnalyticsEvent('pinpointProvider_configured', null);\n                }).catch(function (e) {\n                    logger.debug('Failed to generate endpointId', e);\n                });\n            }\n            else {\n                dispatchAnalyticsEvent('pinpointProvider_configured', null);\n            }\n            this._setupTimer();\n        }\n        else {\n            if (this._timer) {\n                clearInterval(this._timer);\n            }\n        }\n        return this._config;\n    };\n    /**\n     * record an event\n     * @param {Object} params - the params of an event\n     */\n    AWSPinpointProvider.prototype.record = function (params) {\n        return __awaiter(this, void 0, void 0, function () {\n            var credentials, timestamp;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this._getCredentials()];\n                    case 1:\n                        credentials = _a.sent();\n                        if (!credentials || !this._config['appId'] || !this._config['region']) {\n                            logger.debug('cannot send events without credentials, applicationId or region');\n                            return [2 /*return*/, Promise.resolve(false)];\n                        }\n                        timestamp = new Date().getTime();\n                        // attach the session and eventId\n                        this._generateSession(params);\n                        params.event.eventId = uuid_1.v1();\n                        Object.assign(params, { timestamp: timestamp, config: this._config, credentials: credentials });\n                        if (params.event.immediate) {\n                            return [2 /*return*/, this._send(params)];\n                        }\n                        else {\n                            return [2 /*return*/, this._putToBuffer(params)];\n                        }\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    AWSPinpointProvider.prototype._generateSession = function (params) {\n        this._sessionId = this._sessionId || uuid_1.v1();\n        var event = params.event;\n        switch (event.name) {\n            case '_session.start':\n                // refresh the session id and session start time\n                this._sessionStartTimestamp = new Date().getTime();\n                this._sessionId = uuid_1.v1();\n                event.session = {\n                    Id: this._sessionId,\n                    StartTimestamp: new Date(this._sessionStartTimestamp).toISOString()\n                };\n                break;\n            case '_session.stop':\n                var stopTimestamp = new Date().getTime();\n                this._sessionStartTimestamp = this._sessionStartTimestamp || new Date().getTime();\n                this._sessionId = this._sessionId || uuid_1.v1();\n                event.session = {\n                    Id: this._sessionId,\n                    Duration: stopTimestamp - this._sessionStartTimestamp,\n                    StartTimestamp: new Date(this._sessionStartTimestamp).toISOString(),\n                    StopTimestamp: new Date(stopTimestamp).toISOString()\n                };\n                this._sessionId = undefined;\n                this._sessionStartTimestamp = undefined;\n                break;\n            default:\n                this._sessionStartTimestamp = this._sessionStartTimestamp || new Date().getTime();\n                this._sessionId = this._sessionId || uuid_1.v1();\n                event.session = {\n                    Id: this._sessionId,\n                    StartTimestamp: new Date(this._sessionStartTimestamp).toISOString()\n                };\n                break;\n        }\n    };\n    AWSPinpointProvider.prototype._send = function (params) {\n        return __awaiter(this, void 0, void 0, function () {\n            var event, config;\n            return __generator(this, function (_a) {\n                event = params.event, config = params.config;\n                switch (event.name) {\n                    case '_session.start':\n                        return [2 /*return*/, this._startSession(params)];\n                    case '_session.stop':\n                        return [2 /*return*/, this._stopSession(params)];\n                    case '_update_endpoint':\n                        return [2 /*return*/, this._updateEndpoint(params)];\n                    default:\n                        return [2 /*return*/, this._recordCustomEvent(params)];\n                }\n                return [2 /*return*/];\n            });\n        });\n    };\n    AWSPinpointProvider.prototype._generateBatchItemContext = function (params) {\n        var event = params.event, timestamp = params.timestamp, config = params.config, credentials = params.credentials;\n        var name = event.name, attributes = event.attributes, metrics = event.metrics, eventId = event.eventId, session = event.session;\n        var appId = config.appId, endpointId = config.endpointId;\n        var endpointContext = {};\n        var eventParams = {\n            ApplicationId: appId,\n            EventsRequest: {\n                BatchItem: {}\n            }\n        };\n        eventParams.EventsRequest.BatchItem[endpointId] = {};\n        var endpointObj = eventParams.EventsRequest.BatchItem[endpointId];\n        endpointObj['Endpoint'] = endpointContext;\n        endpointObj['Events'] = {};\n        endpointObj['Events'][eventId] = {\n            EventType: name,\n            Timestamp: new Date(timestamp).toISOString(),\n            Attributes: attributes,\n            Metrics: metrics,\n            Session: session\n        };\n        return eventParams;\n    };\n    AWSPinpointProvider.prototype._pinpointPutEvents = function (eventParams) {\n        return __awaiter(this, void 0, void 0, function () {\n            var _this = this;\n            return __generator(this, function (_a) {\n                logger.debug('pinpoint put events with params', eventParams);\n                return [2 /*return*/, new Promise(function (res, rej) {\n                        var request = _this.pinpointClient.putEvents(eventParams);\n                        // in order to keep backward compatiblity\n                        // we are using a legacy api: /apps/{appid}/events/legacy\n                        // so that users don't need to update their IAM Policy\n                        // will use the formal one in the next break release\n                        request.on('build', function () {\n                            request.httpRequest.path = request.httpRequest.path + '/legacy';\n                        });\n                        request.send(function (err, data) {\n                            if (err) {\n                                logger.error('record event failed. ', err);\n                                logger.warn('If you have not updated your Pinpoint IAM Policy' +\n                                    ' with the Action: \\\"mobiletargeting:PutEvents\\\" yet, please do it.' +\n                                    ' This action is not necessary for now' +\n                                    ' but in order to avoid breaking changes in the future,' +\n                                    ' please update it as soon as possible.');\n                                res(false);\n                            }\n                            else {\n                                _this._endpointGenerating = false;\n                                logger.debug('record event success. ', data);\n                                res(true);\n                            }\n                        });\n                    })];\n            });\n        });\n    };\n    /**\n     * @private\n     * @param params\n     */\n    AWSPinpointProvider.prototype._startSession = function (params) {\n        return __awaiter(this, void 0, void 0, function () {\n            var event, timestamp, config, credentials, eventParams;\n            return __generator(this, function (_a) {\n                event = params.event, timestamp = params.timestamp, config = params.config, credentials = params.credentials;\n                this._initClients(config, credentials);\n                logger.debug('record session start');\n                eventParams = this._generateBatchItemContext(params);\n                return [2 /*return*/, this._pinpointPutEvents(eventParams)];\n            });\n        });\n    };\n    /**\n     * @private\n     * @param params\n     */\n    AWSPinpointProvider.prototype._stopSession = function (params) {\n        return __awaiter(this, void 0, void 0, function () {\n            var event, timestamp, config, credentials, eventParams;\n            return __generator(this, function (_a) {\n                event = params.event, timestamp = params.timestamp, config = params.config, credentials = params.credentials;\n                this._initClients(config, credentials);\n                logger.debug('record session stop');\n                eventParams = this._generateBatchItemContext(params);\n                return [2 /*return*/, this._pinpointPutEvents(eventParams)];\n            });\n        });\n    };\n    /**\n     * @private\n     * @param params\n     */\n    AWSPinpointProvider.prototype._recordCustomEvent = function (params) {\n        return __awaiter(this, void 0, void 0, function () {\n            var event, timestamp, config, credentials, eventParams;\n            return __generator(this, function (_a) {\n                event = params.event, timestamp = params.timestamp, config = params.config, credentials = params.credentials;\n                this._initClients(config, credentials);\n                logger.debug('record event with params');\n                eventParams = this._generateBatchItemContext(params);\n                return [2 /*return*/, this._pinpointPutEvents(eventParams)];\n            });\n        });\n    };\n    AWSPinpointProvider.prototype._updateEndpoint = function (params) {\n        return __awaiter(this, void 0, void 0, function () {\n            var timestamp, config, credentials, event, appId, region, endpointId, request, update_params, that;\n            var _this = this;\n            return __generator(this, function (_a) {\n                timestamp = params.timestamp, config = params.config, credentials = params.credentials, event = params.event;\n                appId = config.appId, region = config.region, endpointId = config.endpointId;\n                this._initClients(config, credentials);\n                request = this._endpointRequest(config, core_1.JS.transferKeyToLowerCase(event, [], ['attributes', 'userAttributes', 'Attributes', 'UserAttributes']));\n                update_params = {\n                    ApplicationId: appId,\n                    EndpointId: endpointId,\n                    EndpointRequest: request\n                };\n                that = this;\n                logger.debug('updateEndpoint with params: ', update_params);\n                return [2 /*return*/, new Promise(function (res, rej) {\n                        that.pinpointClient.updateEndpoint(update_params, function (err, data) {\n                            if (err) {\n                                logger.debug('updateEndpoint failed', err);\n                                if (err.message === 'Exceeded maximum endpoint per user count 10') {\n                                    _this._removeUnusedEndpoints(appId, request.User.UserId)\n                                        .then(function () {\n                                        logger.debug('Remove the unused endpoints successfully');\n                                        _this._endpointGenerating = false;\n                                        return res(false);\n                                    }).catch(function (e) {\n                                        logger.warn(\"Failed to remove unused endpoints with error: \" + e);\n                                        logger.warn(\"Please ensure you have updated your Pinpoint IAM Policy \" +\n                                            \"with the Action: \\\"mobiletargeting:GetUserEndpoints\\\" \" +\n                                            \"in order to get endpoints info of the user\");\n                                        return res(false);\n                                    });\n                                }\n                                return res(false);\n                            }\n                            else {\n                                _this._endpointGenerating = false;\n                                logger.debug('updateEndpoint success', data);\n                                return res(true);\n                            }\n                        });\n                    })];\n            });\n        });\n    };\n    AWSPinpointProvider.prototype._removeUnusedEndpoints = function (appId, userId) {\n        return __awaiter(this, void 0, void 0, function () {\n            var _this = this;\n            return __generator(this, function (_a) {\n                return [2 /*return*/, new Promise(function (res, rej) {\n                        _this.pinpointClient.getUserEndpoints({\n                            ApplicationId: appId,\n                            UserId: userId\n                        }, function (err, data) {\n                            if (err) {\n                                logger.debug(\"Failed to get endpoints associated with the userId: \" + userId + \" with error\", err);\n                                return rej(err);\n                            }\n                            var endpoints = data.EndpointsResponse.Item;\n                            logger.debug(\"get endpoints associated with the userId: \" + userId + \" with data\", endpoints);\n                            var endpointToBeDeleted = endpoints[0];\n                            for (var i = 1; i < endpoints.length; i++) {\n                                var timeStamp1 = Date.parse(endpointToBeDeleted['EffectiveDate']);\n                                var timeStamp2 = Date.parse(endpoints[i]['EffectiveDate']);\n                                // delete the one with invalid effective date\n                                if (isNaN(timeStamp1))\n                                    break;\n                                if (isNaN(timeStamp2)) {\n                                    endpointToBeDeleted = endpoints[i];\n                                    break;\n                                }\n                                if (timeStamp2 < timeStamp1) {\n                                    endpointToBeDeleted = endpoints[i];\n                                }\n                            }\n                            // update the endpoint's user id with an empty string\n                            var update_params = {\n                                ApplicationId: appId,\n                                EndpointId: endpointToBeDeleted['Id'],\n                                EndpointRequest: {\n                                    User: {\n                                        UserId: ''\n                                    }\n                                }\n                            };\n                            _this.pinpointClient.updateEndpoint(update_params, function (err, data) {\n                                if (err) {\n                                    logger.debug('Failed to update the endpoint', err);\n                                    return rej(err);\n                                }\n                                logger.debug('The old endpoint is updated with an empty string for user id');\n                                return res(data);\n                            });\n                        });\n                    })];\n            });\n        });\n    };\n    /**\n     * @private\n     * @param config\n     * Init the clients\n     */\n    AWSPinpointProvider.prototype._initClients = function (config, credentials) {\n        return __awaiter(this, void 0, void 0, function () {\n            var region;\n            return __generator(this, function (_a) {\n                logger.debug('init clients');\n                if (this.mobileAnalytics\n                    && this.pinpointClient\n                    && this._config.credentials\n                    && this._config.credentials.sessionToken === credentials.sessionToken\n                    && this._config.credentials.identityId === credentials.identityId) {\n                    logger.debug('no change for aws credentials, directly return from init');\n                    return [2 /*return*/];\n                }\n                this._config.credentials = credentials;\n                region = config.region;\n                logger.debug('init clients with credentials', credentials);\n                this.mobileAnalytics = new MobileAnalytics({ credentials: credentials, region: region });\n                this.pinpointClient = new Pinpoint({ region: region, credentials: credentials });\n                if (core_1.Platform.isReactNative) {\n                    this.pinpointClient.customizeRequests(function (request) {\n                        request.on('build', function (req) {\n                            req.httpRequest.headers['user-agent'] = core_1.Platform.userAgent;\n                        });\n                    });\n                }\n                return [2 /*return*/];\n            });\n        });\n    };\n    AWSPinpointProvider.prototype._getEndpointId = function (cacheKey) {\n        return __awaiter(this, void 0, void 0, function () {\n            var endpointId;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, cache_1.default.getItem(cacheKey)];\n                    case 1:\n                        endpointId = _a.sent();\n                        logger.debug('endpointId from cache', endpointId, 'type', typeof endpointId);\n                        if (!endpointId) {\n                            endpointId = uuid_1.v1();\n                            cache_1.default.setItem(cacheKey, endpointId);\n                        }\n                        return [2 /*return*/, endpointId];\n                }\n            });\n        });\n    };\n    /**\n     * EndPoint request\n     * @return {Object} - The request of updating endpoint\n     */\n    AWSPinpointProvider.prototype._endpointRequest = function (config, event) {\n        var credentials = config.credentials;\n        var clientInfo = this._clientInfo || {};\n        var clientContext = config.clientContext || {};\n        // for now we have three different ways for default endpoint configurations\n        // clientInfo\n        // clientContext (deprecated)\n        // config.endpoint\n        var defaultEndpointConfig = config.endpoint || {};\n        var demographicByClientInfo = {\n            appVersion: clientInfo.appVersion,\n            make: clientInfo.make,\n            model: clientInfo.model,\n            modelVersion: clientInfo.version,\n            platform: clientInfo.platform\n        };\n        // for backward compatibility\n        var clientId = clientContext.clientId, appTitle = clientContext.appTitle, appVersionName = clientContext.appVersionName, appVersionCode = clientContext.appVersionCode, appPackageName = clientContext.appPackageName, demographicByClientContext = __rest(clientContext, [\"clientId\", \"appTitle\", \"appVersionName\", \"appVersionCode\", \"appPackageName\"]);\n        var channelType = event.address ? ((clientInfo.platform === 'android') ? 'GCM' : 'APNS') : undefined;\n        var tmp = __assign({ channelType: channelType, requestId: uuid_1.v1(), effectiveDate: new Date().toISOString() }, defaultEndpointConfig, event, { attributes: __assign({}, defaultEndpointConfig.attributes, event.attributes), demographic: __assign({}, demographicByClientInfo, demographicByClientContext, defaultEndpointConfig.demographic, event.demographic), location: __assign({}, defaultEndpointConfig.location, event.location), metrics: __assign({}, defaultEndpointConfig.metrics, event.metrics), user: {\n                userId: event.userId || defaultEndpointConfig.userId || credentials.identityId,\n                userAttributes: __assign({}, defaultEndpointConfig.userAttributes, event.userAttributes)\n            } });\n        // eliminate unnecessary params\n        var userId = tmp.userId, userAttributes = tmp.userAttributes, name = tmp.name, session = tmp.session, eventId = tmp.eventId, immediate = tmp.immediate, ret = __rest(tmp, [\"userId\", \"userAttributes\", \"name\", \"session\", \"eventId\", \"immediate\"]);\n        return core_1.JS.transferKeyToUpperCase(ret, [], ['metrics', 'userAttributes', 'attributes']);\n    };\n    /**\n     * @private\n     * check if current credentials exists\n     */\n    AWSPinpointProvider.prototype._getCredentials = function () {\n        var that = this;\n        return core_1.Credentials.get()\n            .then(function (credentials) {\n            if (!credentials)\n                return null;\n            logger.debug('set credentials for analytics', credentials);\n            return core_1.Credentials.shear(credentials);\n        })\n            .catch(function (err) {\n            logger.debug('ensure credentials error', err);\n            return null;\n        });\n    };\n    AWSPinpointProvider.category = 'Analytics';\n    AWSPinpointProvider.providerName = 'AWSPinpoint';\n    return AWSPinpointProvider;\n}());\nexports.default = AWSPinpointProvider;\n"},"sourceMaps":{"js":{"version":3,"file":"AWSPinpointProvider.js","sourceRoot":"","sources":["../../src/Providers/AWSPinpointProvider.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright 2017-2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"). You may not use this file except in compliance with\n * the License. A copy of the License is located at\n *\n *     http://aws.amazon.com/apache2.0/\n *\n * or in the \"license\" file accompanying this file. This file is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions\n * and limitations under the License.\n */\nimport {\n    ConsoleLogger as Logger,\n    ClientDevice,\n    Platform,\n    Credentials,\n    Signer,\n    JS,\n    Hub\n} from '@aws-amplify/core';\nimport * as MobileAnalytics from 'aws-sdk/clients/mobileanalytics';\nimport * as Pinpoint from 'aws-sdk/clients/pinpoint';\n\nimport Cache from '@aws-amplify/cache';\n\nimport { AnalyticsProvider } from '../types';\nimport { v1 as uuid } from 'uuid';\n\nconst AMPLIFY_SYMBOL = ((typeof Symbol !== 'undefined' && typeof Symbol.for === 'function') ?\n    Symbol.for('amplify_default') : '@@amplify_default') as Symbol;\n\nconst dispatchAnalyticsEvent = (event, data) => {\n    Hub.dispatch('analytics', { event, data }, 'Analytics', AMPLIFY_SYMBOL);\n};\n\nconst logger = new Logger('AWSPinpointProvider');\nconst NON_RETRYABLE_EXCEPTIONS = ['BadRequestException', 'SerializationException', 'ValidationException'];\n\n// events buffer\nconst BUFFER_SIZE = 1000;\nconst FLUSH_SIZE = 100;\nconst FLUSH_INTERVAL = 5*1000; // 5s\nconst RESEND_LIMIT = 5;\n\n// params: { event: {name: , .... }, timeStamp, config, resendLimits }\nexport default class AWSPinpointProvider implements AnalyticsProvider {\n    static category = 'Analytics';\n    static providerName = 'AWSPinpoint';\n\n    private _config;\n    private mobileAnalytics;\n    private pinpointClient;\n    private _sessionId;\n    private _sessionStartTimestamp;\n    private _buffer;\n    private _clientInfo;\n    private _timer;\n    private _endpointGenerating = true;\n\n    constructor(config?) {\n        this._buffer = [];\n        this._config = config? config : {};\n        this._config.bufferSize = this._config.bufferSize || BUFFER_SIZE;\n        this._config.flushSize = this._config.flushSize || FLUSH_SIZE;\n        this._config.flushInterval = this._config.flushInterval || FLUSH_INTERVAL;\n        this._config.resendLimit = this._config.resendLimit || RESEND_LIMIT;\n        this._clientInfo = ClientDevice.clientInfo();\n    }\n\n    private _setupTimer() {\n        if (this._timer) {\n            clearInterval(this._timer);\n        }\n        const { flushSize, flushInterval } = this._config;\n        const that = this;\n        this._timer = setInterval(\n            () => {\n                const size = this._buffer.length <  flushSize? this._buffer.length : flushSize;\n                for (let i = 0; i < size; i += 1) {\n                    const params = this._buffer.shift();\n                    that._sendFromBuffer(params);\n                    // If this is the first request sent by Analytics module, we should stop sending remaining requests\n                    // to prevent race condition of updating one endpoint when it's being created in the backend\n                    if (this._endpointGenerating) break;\n                }\n            },\n            flushInterval\n        );\n    }\n\n    /**\n     * @private\n     * @param params - params for the event recording\n     * Put events into buffer\n     */\n    private _putToBuffer(params) {\n        const { bufferSize } = this._config;\n        if (this._buffer.length < bufferSize) {\n            this._buffer.push(params);\n            return Promise.resolve(true);\n        } else {\n            logger.debug('exceed analytics events buffer size');\n            return Promise.reject(false);\n        }\n    }\n\n    private async _sendFromBuffer(params) {\n        const { event, config } = params;\n\n        const { appId, region, resendLimit } = config;\n\n        let success = true;\n        switch (event.name) {\n            case '_session.start':\n                success = await this._startSession(params);\n                break;\n            case '_session.stop':\n                success = await this._stopSession(params);\n                break;\n            case '_update_endpoint':\n                success = await this._updateEndpoint(params);\n                break;\n            default:\n                success = await this._recordCustomEvent(params);\n                break;\n        }\n\n        if (!success) {\n            params.resendLimits = typeof params.resendLimits === 'number' ?\n                params.resendLimits : resendLimit;\n            if (params.resendLimits > 0) {\n                logger.debug(\n                    `resending event ${params.eventName} with ${params.resendLimits} retry times left`);\n                params.resendLimits -= 1;\n                this._putToBuffer(params);\n            } else {\n                logger.debug(`retry times used up for event ${params.eventName}`);\n            }\n        }\n    }\n\n    /**\n     * get the category of the plugin\n     */\n    getCategory(): string {\n        return AWSPinpointProvider.category;\n    }\n\n    /**\n     * get provider name of the plugin\n     */\n    getProviderName(): string {\n        return AWSPinpointProvider.providerName;\n    }\n\n    /**\n     * configure the plugin\n     * @param {Object} config - configuration\n     */\n    public configure(config): object {\n        logger.debug('configure Analytics', config);\n        const conf = config? config : {};\n        this._config = Object.assign({}, this._config, conf);\n\n        if (this._config['appId'] && !this._config['disabled']) {\n            if (!this._config['endpointId']) {\n                const cacheKey = this.getProviderName() + '_' + this._config['appId'];\n                this._getEndpointId(cacheKey).then(endpointId => {\n                    logger.debug('setting endpoint id from the cache', endpointId);\n                    this._config['endpointId'] = endpointId;\n                    dispatchAnalyticsEvent('pinpointProvider_configured', null);\n                }).catch(e => {\n                    logger.debug('Failed to generate endpointId', e);\n                });\n            } else {\n                dispatchAnalyticsEvent('pinpointProvider_configured', null);\n            }\n            this._setupTimer();\n        } else {\n            if (this._timer) { clearInterval(this._timer); }\n        }\n        return this._config;\n    }\n\n    /**\n     * record an event\n     * @param {Object} params - the params of an event\n     */\n    public async record(params): Promise<boolean> {\n        const credentials = await this._getCredentials();\n        if (!credentials || !this._config['appId'] || !this._config['region']){\n            logger.debug('cannot send events without credentials, applicationId or region');\n            return Promise.resolve(false);\n        }\n        const timestamp = new Date().getTime();\n        // attach the session and eventId\n        this._generateSession(params);\n        params.event.eventId = uuid();\n\n        Object.assign(params, { timestamp, config: this._config, credentials });\n        if (params.event.immediate) {\n            return this._send(params);\n        } else {\n            return this._putToBuffer(params);\n        }\n    }\n\n    private _generateSession(params) {\n        this._sessionId = this._sessionId || uuid();\n        const { event } = params;\n\n        switch (event.name) {\n            case '_session.start':\n                // refresh the session id and session start time\n                this._sessionStartTimestamp = new Date().getTime();\n                this._sessionId = uuid();\n                event.session = {\n                    Id: this._sessionId,\n                    StartTimestamp: new Date(this._sessionStartTimestamp).toISOString()\n                };\n                break;\n            case '_session.stop':\n                const stopTimestamp = new Date().getTime();\n                this._sessionStartTimestamp = this._sessionStartTimestamp || new Date().getTime();\n                this._sessionId = this._sessionId || uuid();\n                event.session = {\n                    Id: this._sessionId,\n                    Duration: stopTimestamp - this._sessionStartTimestamp,\n                    StartTimestamp: new Date(this._sessionStartTimestamp).toISOString(),\n                    StopTimestamp: new Date(stopTimestamp).toISOString()\n                };\n                this._sessionId = undefined;\n                this._sessionStartTimestamp = undefined;\n                break;\n            default:\n                this._sessionStartTimestamp = this._sessionStartTimestamp || new Date().getTime();\n                this._sessionId = this._sessionId || uuid();\n                event.session = {\n                    Id: this._sessionId,\n                    StartTimestamp: new Date(this._sessionStartTimestamp).toISOString()\n                };\n                break;\n        }\n    }\n\n    private async _send(params) {\n        const { event, config } = params;\n\n        switch (event.name) {\n            case '_session.start':\n                return this._startSession(params);\n            case '_session.stop':\n                return this._stopSession(params);\n            case '_update_endpoint':\n                return this._updateEndpoint(params);\n            default:\n                return this._recordCustomEvent(params);\n        }\n    }\n\n    private _generateBatchItemContext(params) {\n        const { event, timestamp, config, credentials } = params;\n        const { name, attributes, metrics, eventId, session } = event;\n        const { appId, endpointId } = config;\n\n        const endpointContext = {};\n\n        const eventParams = {\n            ApplicationId: appId,\n            EventsRequest: {\n                BatchItem: {}\n            }\n        };\n\n        eventParams.EventsRequest.BatchItem[endpointId] = {};\n        const endpointObj = eventParams.EventsRequest.BatchItem[endpointId];\n        endpointObj['Endpoint'] = endpointContext;\n        endpointObj['Events'] = {};\n        endpointObj['Events'][eventId] = {\n            EventType: name,\n            Timestamp: new Date(timestamp).toISOString(),\n            Attributes: attributes,\n            Metrics: metrics,\n            Session: session\n        };\n\n        return eventParams;\n    }\n\n    private async _pinpointPutEvents(eventParams) {\n        logger.debug('pinpoint put events with params', eventParams);\n        return new Promise<any>((res, rej) => {\n            const request = this.pinpointClient.putEvents(eventParams);\n            // in order to keep backward compatiblity\n            // we are using a legacy api: /apps/{appid}/events/legacy\n            // so that users don't need to update their IAM Policy\n            // will use the formal one in the next break release\n            request.on('build', function() {\n                request.httpRequest.path = request.httpRequest.path + '/legacy';\n            });\n\n            request.send((err, data) => {\n                if (err) {\n                    logger.error('record event failed. ', err);\n                    logger.warn(\n                        'If you have not updated your Pinpoint IAM Policy' + \n                        ' with the Action: \\\"mobiletargeting:PutEvents\\\" yet, please do it.' + \n                        ' This action is not necessary for now' + \n                        ' but in order to avoid breaking changes in the future,' + \n                        ' please update it as soon as possible.'\n                    );\n                    res(false);\n                }\n                else {\n                    this._endpointGenerating = false;\n                    logger.debug('record event success. ', data);\n                    res(true);\n                }\n            });\n        });\n    }\n\n    /**\n     * @private\n     * @param params\n     */\n    private async _startSession(params) {\n        // credentials updated\n        const { event, timestamp, config, credentials } = params;\n        this._initClients(config, credentials);\n\n        logger.debug('record session start');\n        const eventParams = this._generateBatchItemContext(params);\n        return this._pinpointPutEvents(eventParams);\n    }\n\n    /**\n     * @private\n     * @param params\n     */\n    private async _stopSession(params) {\n        // credentials updated\n        const { event, timestamp, config, credentials } = params;\n        this._initClients(config, credentials);\n\n        logger.debug('record session stop');\n        const eventParams = this._generateBatchItemContext(params);\n        return this._pinpointPutEvents(eventParams);\n    }\n\n    /**\n     * @private\n     * @param params\n     */\n    private async _recordCustomEvent(params) {\n        // credentials updated\n        const { event, timestamp, config, credentials } = params;\n        this._initClients(config, credentials);\n\n        logger.debug('record event with params');\n        const eventParams = this._generateBatchItemContext(params);\n        return this._pinpointPutEvents(eventParams);\n    }\n\n    private async _updateEndpoint(params) : Promise<boolean> {\n        // credentials updated\n        const { timestamp, config, credentials, event } = params;\n        const { appId, region, endpointId } = config;\n\n        this._initClients(config, credentials);\n\n        const request = this._endpointRequest(\n            config,\n            JS.transferKeyToLowerCase(event, [], ['attributes', 'userAttributes', 'Attributes', 'UserAttributes'])\n        );\n        const update_params = {\n            ApplicationId: appId,\n            EndpointId: endpointId,\n            EndpointRequest: request\n        };\n\n        const that = this;\n        logger.debug('updateEndpoint with params: ', update_params);\n        return new Promise<boolean>((res, rej) => {\n            that.pinpointClient.updateEndpoint(update_params, (err, data) => {\n                if (err) {\n                    logger.debug('updateEndpoint failed', err);\n                    if (err.message === 'Exceeded maximum endpoint per user count 10') {\n                        this._removeUnusedEndpoints(appId, request.User.UserId)\n                        .then(() => {\n                            logger.debug('Remove the unused endpoints successfully');\n                            this._endpointGenerating = false;\n                            return res(false);\n                        }).catch(e => {\n                            logger.warn(`Failed to remove unused endpoints with error: ${e}`);\n                            logger.warn(`Please ensure you have updated your Pinpoint IAM Policy ` +\n                                `with the Action: \"mobiletargeting:GetUserEndpoints\" ` +\n                                `in order to get endpoints info of the user`);\n                            return res(false);\n                        });\n                    }\n                    return res(false);\n                } else {\n                    this._endpointGenerating = false;\n                    logger.debug('updateEndpoint success', data);\n                    return res(true);\n                }\n            });\n        });\n    }\n\n    private async _removeUnusedEndpoints(appId, userId) {\n        return new Promise((res, rej) => {\n            this.pinpointClient.getUserEndpoints(\n                {\n                    ApplicationId: appId,\n                    UserId: userId\n                },\n                (err, data) => {\n                    if (err) {\n                        logger.debug(`Failed to get endpoints associated with the userId: ${userId} with error`, err);\n                        return rej(err);\n                    }\n                    const endpoints = data.EndpointsResponse.Item;\n                    logger.debug(`get endpoints associated with the userId: ${userId} with data`, endpoints);\n                    let endpointToBeDeleted = endpoints[0];\n                    for (let i = 1; i < endpoints.length; i++) {\n                        const timeStamp1 = Date.parse(endpointToBeDeleted['EffectiveDate']);\n                        const timeStamp2 = Date.parse(endpoints[i]['EffectiveDate']);\n                        // delete the one with invalid effective date\n                        if (isNaN(timeStamp1)) break;\n                        if (isNaN(timeStamp2)) { endpointToBeDeleted = endpoints[i]; break; }\n\n                        if (timeStamp2 < timeStamp1) {\n                            endpointToBeDeleted = endpoints[i];\n                        }\n                    }\n                    // update the endpoint's user id with an empty string\n                    const update_params = {\n                        ApplicationId: appId,\n                        EndpointId: endpointToBeDeleted['Id'],\n                        EndpointRequest: {\n                            User: {\n                                UserId: ''\n                            }\n                        }\n                    };\n                    this.pinpointClient.updateEndpoint(\n                        update_params,\n                        (err, data) => {\n                            if (err) {\n                                logger.debug('Failed to update the endpoint', err);\n                                return rej(err);\n                            }\n                            logger.debug('The old endpoint is updated with an empty string for user id');\n                            return res(data);\n                        });\n            });\n        });\n\n    }\n\n    /**\n     * @private\n     * @param config\n     * Init the clients\n     */\n    private async _initClients(config, credentials) {\n        logger.debug('init clients');\n\n        if (this.mobileAnalytics\n            && this.pinpointClient\n            && this._config.credentials\n            && this._config.credentials.sessionToken === credentials.sessionToken\n            && this._config.credentials.identityId === credentials.identityId) {\n            logger.debug('no change for aws credentials, directly return from init');\n            return;\n        }\n\n        this._config.credentials = credentials;\n        const { region } = config;\n        logger.debug('init clients with credentials', credentials);\n        this.mobileAnalytics = new MobileAnalytics({ credentials, region });\n        this.pinpointClient = new Pinpoint({ region, credentials });\n        if (Platform.isReactNative) {\n            this.pinpointClient.customizeRequests(function(request) {\n                request.on('build', function(req) {\n                    req.httpRequest.headers['user-agent'] = Platform.userAgent;\n                });\n            });\n        }\n\n    }\n\n    private async _getEndpointId(cacheKey) {\n        // try to get from cache\n        let endpointId = await Cache.getItem(cacheKey);\n        logger.debug('endpointId from cache', endpointId, 'type', typeof endpointId);\n        if (!endpointId) {\n            endpointId = uuid();\n            Cache.setItem(cacheKey, endpointId);\n        }\n        return endpointId;\n    }\n\n    /**\n     * EndPoint request\n     * @return {Object} - The request of updating endpoint\n     */\n    private _endpointRequest(config, event) {\n        const { credentials } = config;\n        const clientInfo = this._clientInfo || {};\n        const clientContext = config.clientContext || {};\n        // for now we have three different ways for default endpoint configurations\n        // clientInfo\n        // clientContext (deprecated)\n        // config.endpoint\n        const defaultEndpointConfig = config.endpoint || {};\n        const demographicByClientInfo = {\n            appVersion: clientInfo.appVersion,\n            make: clientInfo.make,\n            model: clientInfo.model,\n            modelVersion: clientInfo.version,\n            platform: clientInfo.platform\n        };\n        // for backward compatibility\n        const {\n            clientId,\n            appTitle,\n            appVersionName,\n            appVersionCode,\n            appPackageName,\n            ...demographicByClientContext\n        } = clientContext;\n        const channelType = event.address? ((clientInfo.platform === 'android') ? 'GCM' : 'APNS') : undefined;\n        const tmp = {\n            channelType,\n            requestId: uuid(),\n            effectiveDate:new Date().toISOString(),\n            ...defaultEndpointConfig,\n            ...event,\n            attributes: {\n                ...defaultEndpointConfig.attributes,\n                ...event.attributes\n            },\n            demographic: {\n                ...demographicByClientInfo,\n                ...demographicByClientContext,\n                ...defaultEndpointConfig.demographic,\n                ...event.demographic\n            },\n            location: {\n                ...defaultEndpointConfig.location,\n                ...event.location\n            },\n            metrics: {\n                ...defaultEndpointConfig.metrics,\n                ...event.metrics\n            },\n            user: {\n                userId: event.userId || defaultEndpointConfig.userId || credentials.identityId,\n                userAttributes: {\n                    ...defaultEndpointConfig.userAttributes,\n                    ...event.userAttributes\n                }\n            }\n        };\n\n        // eliminate unnecessary params\n        const { userId, userAttributes, name, session, eventId, immediate, ...ret } = tmp;\n        return JS.transferKeyToUpperCase(ret, [], ['metrics', 'userAttributes', 'attributes']);\n    }\n\n    /**\n     * @private\n     * check if current credentials exists\n     */\n    private _getCredentials() {\n        const that = this;\n        return Credentials.get()\n            .then(credentials => {\n                if (!credentials) return null;\n                logger.debug('set credentials for analytics', credentials);\n                return Credentials.shear(credentials);\n            })\n            .catch(err => {\n                logger.debug('ensure credentials error', err);\n                return null;\n            });\n    }\n}\n"]}},"error":null,"hash":"59a06bff0f615769fc83c418a012449d","cacheData":{"env":{}}}