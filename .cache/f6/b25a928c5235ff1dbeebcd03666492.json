{"id":"node_modules/@aws-amplify/auth/lib/Auth.js","dependencies":[{"name":"C:\\Users\\太田遥人\\Desktop\\auth-kampo\\node_modules\\@aws-amplify\\auth\\lib\\Auth.js.map","includedInParent":true,"mtime":1557861886000},{"name":"C:\\Users\\太田遥人\\Desktop\\auth-kampo\\node_modules\\@aws-amplify\\auth\\src\\Auth.ts","includedInParent":true,"mtime":1557861738000},{"name":"C:\\Users\\太田遥人\\Desktop\\auth-kampo\\node_modules\\@aws-amplify\\auth\\package.json","includedInParent":true,"mtime":1560308010597},{"name":"./types","loc":{"line":50,"column":22},"parent":"C:\\Users\\太田遥人\\Desktop\\auth-kampo\\node_modules\\@aws-amplify\\auth\\lib\\Auth.js","resolved":"C:\\Users\\太田遥人\\Desktop\\auth-kampo\\node_modules\\@aws-amplify\\auth\\lib\\types\\index.js"},{"name":"@aws-amplify/core","loc":{"line":51,"column":21},"parent":"C:\\Users\\太田遥人\\Desktop\\auth-kampo\\node_modules\\@aws-amplify\\auth\\lib\\Auth.js","resolved":"C:\\Users\\太田遥人\\Desktop\\auth-kampo\\node_modules\\@aws-amplify\\core\\lib\\index.js"},{"name":"amazon-cognito-identity-js","loc":{"line":52,"column":43},"parent":"C:\\Users\\太田遥人\\Desktop\\auth-kampo\\node_modules\\@aws-amplify\\auth\\lib\\Auth.js","resolved":"C:\\Users\\太田遥人\\Desktop\\auth-kampo\\node_modules\\amazon-cognito-identity-js\\es\\index.js"},{"name":"url","loc":{"line":53,"column":20},"parent":"C:\\Users\\太田遥人\\Desktop\\auth-kampo\\node_modules\\@aws-amplify\\auth\\lib\\Auth.js","resolved":"C:\\Users\\太田遥人\\Desktop\\auth-kampo\\node_modules\\url\\url.js"},{"name":"./OAuth/OAuth","loc":{"line":54,"column":22},"parent":"C:\\Users\\太田遥人\\Desktop\\auth-kampo\\node_modules\\@aws-amplify\\auth\\lib\\Auth.js","resolved":"C:\\Users\\太田遥人\\Desktop\\auth-kampo\\node_modules\\@aws-amplify\\auth\\lib\\OAuth\\OAuth.js"},{"name":"./urlListener","loc":{"line":55,"column":28},"parent":"C:\\Users\\太田遥人\\Desktop\\auth-kampo\\node_modules\\@aws-amplify\\auth\\lib\\Auth.js","resolved":"C:\\Users\\太田遥人\\Desktop\\auth-kampo\\node_modules\\@aws-amplify\\auth\\lib\\urlListener.js"}],"generated":{"js":"\"use strict\";\n/*\n * Copyright 2017-2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"). You may not use this file except in compliance with\n * the License. A copy of the License is located at\n *\n *     http://aws.amazon.com/apache2.0/\n *\n * or in the \"license\" file accompanying this file. This file is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions\n * and limitations under the License.\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar types_1 = require(\"./types\");\nvar core_1 = require(\"@aws-amplify/core\");\nvar amazon_cognito_identity_js_1 = require(\"amazon-cognito-identity-js\");\nvar url_1 = require(\"url\");\nvar OAuth_1 = require(\"./OAuth/OAuth\");\nvar urlListener_1 = require(\"./urlListener\");\nvar logger = new core_1.ConsoleLogger('AuthClass');\nvar USER_ADMIN_SCOPE = 'aws.cognito.signin.user.admin';\nvar AMPLIFY_SYMBOL = ((typeof Symbol !== 'undefined' && typeof Symbol.for === 'function') ?\n    Symbol.for('amplify_default') : '@@amplify_default');\nvar dispatchAuthEvent = function (event, data, message) {\n    core_1.Hub.dispatch('auth', { event: event, data: data, message: message }, 'Auth', AMPLIFY_SYMBOL);\n};\nvar CognitoHostedUIIdentityProvider;\n(function (CognitoHostedUIIdentityProvider) {\n    CognitoHostedUIIdentityProvider[\"Cognito\"] = \"COGNITO\";\n    CognitoHostedUIIdentityProvider[\"Google\"] = \"Google\";\n    CognitoHostedUIIdentityProvider[\"Facebook\"] = \"Facebook\";\n    CognitoHostedUIIdentityProvider[\"Amazon\"] = \"LoginWithAmazon\";\n})(CognitoHostedUIIdentityProvider = exports.CognitoHostedUIIdentityProvider || (exports.CognitoHostedUIIdentityProvider = {}));\n/**\n* Provide authentication steps\n*/\nvar AuthClass = /** @class */ (function () {\n    /**\n     * Initialize Auth with AWS configurations\n     * @param {Object} config - Configuration of the Auth\n     */\n    function AuthClass(config) {\n        var _this = this;\n        this.userPool = null;\n        this.user = null;\n        this.configure(config);\n        this.currentUserCredentials = this.currentUserCredentials.bind(this);\n        if (core_1.AWS.config) {\n            core_1.AWS.config.update({ customUserAgent: core_1.Constants.userAgent });\n        }\n        else {\n            logger.warn('No AWS.config');\n        }\n        core_1.Hub.listen('auth', function (_a) {\n            var payload = _a.payload;\n            var event = payload.event;\n            switch (event) {\n                case 'signIn':\n                    _this._storage.setItem('amplify-signin-with-hostedUI', 'false');\n                    break;\n                case 'signOut':\n                    _this._storage.removeItem('amplify-signin-with-hostedUI');\n                    break;\n                case 'cognitoHostedUI':\n                    _this._storage.setItem('amplify-signin-with-hostedUI', 'true');\n                    break;\n            }\n        });\n    }\n    AuthClass.prototype.getModuleName = function () {\n        return 'Auth';\n    };\n    AuthClass.prototype.configure = function (config) {\n        var _this = this;\n        if (!config)\n            return this._config || {};\n        logger.debug('configure Auth');\n        var conf = Object.assign({}, this._config, core_1.Parser.parseMobilehubConfig(config).Auth, config);\n        this._config = conf;\n        var _a = this._config, userPoolId = _a.userPoolId, userPoolWebClientId = _a.userPoolWebClientId, cookieStorage = _a.cookieStorage, oauth = _a.oauth, region = _a.region, identityPoolId = _a.identityPoolId, mandatorySignIn = _a.mandatorySignIn, refreshHandlers = _a.refreshHandlers, identityPoolRegion = _a.identityPoolRegion;\n        if (!this._config.storage) {\n            // backward compatbility\n            if (cookieStorage)\n                this._storage = new amazon_cognito_identity_js_1.CookieStorage(cookieStorage);\n            else {\n                this._storage = new core_1.StorageHelper().getStorage();\n            }\n        }\n        else {\n            if (core_1.JS.isEmpty(this._config.storage)) {\n                logger.error('The storage in the Auth config can not be empty!');\n                throw new Error('Empty storage object');\n            }\n            this._storage = this._config.storage;\n        }\n        this._storageSync = Promise.resolve();\n        if (typeof this._storage['sync'] === 'function') {\n            this._storageSync = this._storage['sync']();\n        }\n        if (userPoolId) {\n            var userPoolData = {\n                UserPoolId: userPoolId,\n                ClientId: userPoolWebClientId,\n            };\n            userPoolData.Storage = this._storage;\n            this.userPool = new amazon_cognito_identity_js_1.CognitoUserPool(userPoolData);\n        }\n        core_1.Credentials.configure({\n            mandatorySignIn: mandatorySignIn,\n            region: identityPoolRegion || region,\n            userPoolId: userPoolId,\n            identityPoolId: identityPoolId,\n            refreshHandlers: refreshHandlers,\n            storage: this._storage\n        });\n        // initiailize cognitoauth client if hosted ui options provided\n        // to keep backward compatibility:\n        var cognitoHostedUIConfig = oauth ? (types_1.isCognitoHostedOpts(this._config.oauth)\n            ? oauth : oauth.awsCognito)\n            : undefined;\n        if (cognitoHostedUIConfig) {\n            var cognitoAuthParams = Object.assign({\n                cognitoClientId: userPoolWebClientId,\n                UserPoolId: userPoolId,\n                domain: cognitoHostedUIConfig['domain'],\n                scopes: cognitoHostedUIConfig['scope'],\n                redirectSignIn: cognitoHostedUIConfig['redirectSignIn'],\n                redirectSignOut: cognitoHostedUIConfig['redirectSignOut'],\n                responseType: cognitoHostedUIConfig['responseType'],\n                Storage: this._storage,\n                urlOpener: cognitoHostedUIConfig['urlOpener']\n            }, cognitoHostedUIConfig['options']);\n            this._oAuthHandler = new OAuth_1.default({\n                scopes: cognitoAuthParams.scopes,\n                config: cognitoAuthParams,\n                cognitoClientId: cognitoAuthParams.cognitoClientId\n            });\n            // **NOTE** - Remove this in a future major release as it is a breaking change\n            urlListener_1.default(function (_a) {\n                var url = _a.url;\n                _this._handleAuthResponse(url);\n            });\n        }\n        dispatchAuthEvent('configured', null, \"The Auth category has been configured successfully\");\n        return this._config;\n    };\n    /**\n     * Sign up with username, password and other attrbutes like phone, email\n     * @param {String | object} params - The user attirbutes used for signin\n     * @param {String[]} restOfAttrs - for the backward compatability\n     * @return - A promise resolves callback data if success\n     */\n    AuthClass.prototype.signUp = function (params) {\n        var _this = this;\n        var restOfAttrs = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            restOfAttrs[_i - 1] = arguments[_i];\n        }\n        if (!this.userPool) {\n            return Promise.reject('No userPool');\n        }\n        var username = null;\n        var password = null;\n        var attributes = [];\n        var validationData = null;\n        if (params && typeof params === 'string') {\n            username = params;\n            password = restOfAttrs ? restOfAttrs[0] : null;\n            var email = restOfAttrs ? restOfAttrs[1] : null;\n            var phone_number = restOfAttrs ? restOfAttrs[2] : null;\n            if (email)\n                attributes.push({ Name: 'email', Value: email });\n            if (phone_number)\n                attributes.push({ Name: 'phone_number', Value: phone_number });\n        }\n        else if (params && typeof params === 'object') {\n            username = params['username'];\n            password = params['password'];\n            var attrs_1 = params['attributes'];\n            if (attrs_1) {\n                Object.keys(attrs_1).map(function (key) {\n                    var ele = { Name: key, Value: attrs_1[key] };\n                    attributes.push(ele);\n                });\n            }\n            validationData = params['validationData'] || null;\n        }\n        else {\n            return Promise.reject('The first parameter should either be non-null string or object');\n        }\n        if (!username) {\n            return Promise.reject('Username cannot be empty');\n        }\n        if (!password) {\n            return Promise.reject('Password cannot be empty');\n        }\n        logger.debug('signUp attrs:', attributes);\n        logger.debug('signUp validation data:', validationData);\n        return new Promise(function (resolve, reject) {\n            _this.userPool.signUp(username, password, attributes, validationData, function (err, data) {\n                if (err) {\n                    dispatchAuthEvent('signUp_failure', err, username + \" failed to signup\");\n                    reject(err);\n                }\n                else {\n                    dispatchAuthEvent('signUp', data, username + \" has signed up successfully\");\n                    resolve(data);\n                }\n            });\n        });\n    };\n    /**\n     * Send the verfication code to confirm sign up\n     * @param {String} username - The username to be confirmed\n     * @param {String} code - The verification code\n     * @param {ConfirmSignUpOptions} options - other options for confirm signup\n     * @return - A promise resolves callback data if success\n     */\n    AuthClass.prototype.confirmSignUp = function (username, code, options) {\n        if (!this.userPool) {\n            return Promise.reject('No userPool');\n        }\n        if (!username) {\n            return Promise.reject('Username cannot be empty');\n        }\n        if (!code) {\n            return Promise.reject('Code cannot be empty');\n        }\n        var user = this.createCognitoUser(username);\n        var forceAliasCreation = options && typeof options.forceAliasCreation === 'boolean'\n            ? options.forceAliasCreation : true;\n        return new Promise(function (resolve, reject) {\n            user.confirmRegistration(code, forceAliasCreation, function (err, data) {\n                if (err) {\n                    reject(err);\n                }\n                else {\n                    resolve(data);\n                }\n            });\n        });\n    };\n    /**\n     * Resend the verification code\n     * @param {String} username - The username to be confirmed\n     * @return - A promise resolves data if success\n     */\n    AuthClass.prototype.resendSignUp = function (username) {\n        if (!this.userPool) {\n            return Promise.reject('No userPool');\n        }\n        if (!username) {\n            return Promise.reject('Username cannot be empty');\n        }\n        var user = this.createCognitoUser(username);\n        return new Promise(function (resolve, reject) {\n            user.resendConfirmationCode(function (err, data) {\n                if (err) {\n                    reject(err);\n                }\n                else {\n                    resolve(data);\n                }\n            });\n        });\n    };\n    /**\n     * Sign in\n     * @param {String | SignInOpts} usernameOrSignInOpts - The username to be signed in or the sign in options\n     * @param {String} password - The password of the username\n     * @return - A promise resolves the CognitoUser\n     */\n    AuthClass.prototype.signIn = function (usernameOrSignInOpts, pw) {\n        if (!this.userPool) {\n            return Promise.reject('No userPool');\n        }\n        var username = null;\n        var password = null;\n        var validationData = {};\n        // for backward compatibility\n        if (typeof usernameOrSignInOpts === 'string') {\n            username = usernameOrSignInOpts;\n            password = pw;\n        }\n        else if (types_1.isUsernamePasswordOpts(usernameOrSignInOpts)) {\n            if (typeof pw !== 'undefined') {\n                logger.warn('The password should be defined under the first parameter object!');\n            }\n            username = usernameOrSignInOpts.username;\n            password = usernameOrSignInOpts.password;\n            validationData = usernameOrSignInOpts.validationData;\n        }\n        else {\n            return Promise.reject(new Error('The username should either be a string or one of the sign in types'));\n        }\n        if (!username) {\n            return Promise.reject('Username cannot be empty');\n        }\n        var authDetails = new amazon_cognito_identity_js_1.AuthenticationDetails({\n            Username: username,\n            Password: password,\n            ValidationData: validationData\n        });\n        if (password) {\n            return this.signInWithPassword(authDetails);\n        }\n        else {\n            return this.signInWithoutPassword(authDetails);\n        }\n    };\n    /**\n     * Return an object with the authentication callbacks\n     * @param {CognitoUser} user - the cognito user object\n     * @param {} resolve - function called when resolving the current step\n     * @param {} reject - function called when rejecting the current step\n     * @return - an object with the callback methods for user authentication\n     */\n    AuthClass.prototype.authCallbacks = function (user, resolve, reject) {\n        var _this = this;\n        var that = this;\n        return {\n            onSuccess: function (session) { return __awaiter(_this, void 0, void 0, function () {\n                var cred, e_1, currentUser, e_2;\n                return __generator(this, function (_a) {\n                    switch (_a.label) {\n                        case 0:\n                            logger.debug(session);\n                            delete (user['challengeName']);\n                            delete (user['challengeParam']);\n                            _a.label = 1;\n                        case 1:\n                            _a.trys.push([1, 4, 5, 9]);\n                            return [4 /*yield*/, core_1.Credentials.clear()];\n                        case 2:\n                            _a.sent();\n                            return [4 /*yield*/, core_1.Credentials.set(session, 'session')];\n                        case 3:\n                            cred = _a.sent();\n                            logger.debug('succeed to get cognito credentials', cred);\n                            return [3 /*break*/, 9];\n                        case 4:\n                            e_1 = _a.sent();\n                            logger.debug('cannot get cognito credentials', e_1);\n                            return [3 /*break*/, 9];\n                        case 5:\n                            _a.trys.push([5, 7, , 8]);\n                            return [4 /*yield*/, this.currentUserPoolUser()];\n                        case 6:\n                            currentUser = _a.sent();\n                            that.user = currentUser;\n                            dispatchAuthEvent('signIn', currentUser, \"A user \" + user.getUsername() + \" has been signed in\");\n                            resolve(currentUser);\n                            return [3 /*break*/, 8];\n                        case 7:\n                            e_2 = _a.sent();\n                            logger.error('Failed to get the signed in user', e_2);\n                            reject(e_2);\n                            return [3 /*break*/, 8];\n                        case 8: return [7 /*endfinally*/];\n                        case 9: return [2 /*return*/];\n                    }\n                });\n            }); },\n            onFailure: function (err) {\n                logger.debug('signIn failure', err);\n                dispatchAuthEvent('signIn_failure', err, user.getUsername() + \" failed to signin\");\n                reject(err);\n            },\n            customChallenge: function (challengeParam) {\n                logger.debug('signIn custom challenge answer required');\n                user['challengeName'] = 'CUSTOM_CHALLENGE';\n                user['challengeParam'] = challengeParam;\n                resolve(user);\n            },\n            mfaRequired: function (challengeName, challengeParam) {\n                logger.debug('signIn MFA required');\n                user['challengeName'] = challengeName;\n                user['challengeParam'] = challengeParam;\n                resolve(user);\n            },\n            mfaSetup: function (challengeName, challengeParam) {\n                logger.debug('signIn mfa setup', challengeName);\n                user['challengeName'] = challengeName;\n                user['challengeParam'] = challengeParam;\n                resolve(user);\n            },\n            newPasswordRequired: function (userAttributes, requiredAttributes) {\n                logger.debug('signIn new password');\n                user['challengeName'] = 'NEW_PASSWORD_REQUIRED';\n                user['challengeParam'] = {\n                    userAttributes: userAttributes,\n                    requiredAttributes: requiredAttributes\n                };\n                resolve(user);\n            },\n            totpRequired: function (challengeName, challengeParam) {\n                logger.debug('signIn totpRequired');\n                user['challengeName'] = challengeName;\n                user['challengeParam'] = challengeParam;\n                resolve(user);\n            },\n            selectMFAType: function (challengeName, challengeParam) {\n                logger.debug('signIn selectMFAType', challengeName);\n                user['challengeName'] = challengeName;\n                user['challengeParam'] = challengeParam;\n                resolve(user);\n            }\n        };\n    };\n    /**\n     * Sign in with a password\n     * @private\n     * @param {AuthenticationDetails} authDetails - the user sign in data\n     * @return - A promise resolves the CognitoUser object if success or mfa required\n     */\n    AuthClass.prototype.signInWithPassword = function (authDetails) {\n        var _this = this;\n        var user = this.createCognitoUser(authDetails.getUsername());\n        return new Promise(function (resolve, reject) {\n            user.authenticateUser(authDetails, _this.authCallbacks(user, resolve, reject));\n        });\n    };\n    /**\n     * Sign in without a password\n     * @private\n     * @param {AuthenticationDetails} authDetails - the user sign in data\n     * @return - A promise resolves the CognitoUser object if success or mfa required\n     */\n    AuthClass.prototype.signInWithoutPassword = function (authDetails) {\n        var _this = this;\n        var user = this.createCognitoUser(authDetails.getUsername());\n        user.setAuthenticationFlowType('CUSTOM_AUTH');\n        return new Promise(function (resolve, reject) {\n            user.initiateAuth(authDetails, _this.authCallbacks(user, resolve, reject));\n        });\n    };\n    /**\n     * get user current preferred mfa option\n     * this method doesn't work with totp, we need to deprecate it.\n     * @deprecated\n     * @param {CognitoUser} user - the current user\n     * @return - A promise resolves the current preferred mfa option if success\n     */\n    AuthClass.prototype.getMFAOptions = function (user) {\n        return new Promise(function (res, rej) {\n            user.getMFAOptions(function (err, mfaOptions) {\n                if (err) {\n                    logger.debug('get MFA Options failed', err);\n                    rej(err);\n                    return;\n                }\n                logger.debug('get MFA options success', mfaOptions);\n                res(mfaOptions);\n                return;\n            });\n        });\n    };\n    /**\n     * get preferred mfa method\n     * @param {CognitoUser} user - the current cognito user\n     * @param {GetPreferredMFAOpts} params - options for getting the current user preferred MFA\n     */\n    AuthClass.prototype.getPreferredMFA = function (user, params) {\n        var that = this;\n        return new Promise(function (res, rej) {\n            var bypassCache = params ? params.bypassCache : false;\n            user.getUserData(function (err, data) {\n                if (err) {\n                    logger.debug('getting preferred mfa failed', err);\n                    rej(err);\n                    return;\n                }\n                var mfaType = that._getMfaTypeFromUserData(data);\n                if (!mfaType) {\n                    rej('invalid MFA Type');\n                    return;\n                }\n                else {\n                    res(mfaType);\n                    return;\n                }\n            }, { bypassCache: bypassCache });\n        });\n    };\n    AuthClass.prototype._getMfaTypeFromUserData = function (data) {\n        var ret = null;\n        var preferredMFA = data.PreferredMfaSetting;\n        // if the user has used Auth.setPreferredMFA() to setup the mfa type\n        // then the \"PreferredMfaSetting\" would exist in the response\n        if (preferredMFA) {\n            ret = preferredMFA;\n        }\n        else {\n            // if mfaList exists but empty, then its noMFA\n            var mfaList = data.UserMFASettingList;\n            if (!mfaList) {\n                // if SMS was enabled by using Auth.enableSMS(),\n                // the response would contain MFAOptions\n                // as for now Cognito only supports for SMS, so we will say it is 'SMS_MFA'\n                // if it does not exist, then it should be NOMFA\n                var MFAOptions = data.MFAOptions;\n                if (MFAOptions) {\n                    ret = 'SMS_MFA';\n                }\n                else {\n                    ret = 'NOMFA';\n                }\n            }\n            else if (mfaList.length === 0) {\n                ret = 'NOMFA';\n            }\n            else {\n                logger.debug('invalid case for getPreferredMFA', data);\n            }\n        }\n        return ret;\n    };\n    AuthClass.prototype._getUserData = function (user, params) {\n        return new Promise(function (res, rej) {\n            user.getUserData(function (err, data) {\n                if (err) {\n                    logger.debug('getting user data failed', err);\n                    rej(err);\n                    return;\n                }\n                else {\n                    res(data);\n                    return;\n                }\n            }, params);\n        });\n    };\n    /**\n     * set preferred MFA method\n     * @param {CognitoUser} user - the current Cognito user\n     * @param {string} mfaMethod - preferred mfa method\n     * @return - A promise resolve if success\n     */\n    AuthClass.prototype.setPreferredMFA = function (user, mfaMethod) {\n        return __awaiter(this, void 0, void 0, function () {\n            var userData, smsMfaSettings, totpMfaSettings, _a, mfaList, currentMFAType, that;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0: return [4 /*yield*/, this._getUserData(user, { bypassCache: true })];\n                    case 1:\n                        userData = _b.sent();\n                        smsMfaSettings = null;\n                        totpMfaSettings = null;\n                        _a = mfaMethod;\n                        switch (_a) {\n                            case 'TOTP' || 'SOFTWARE_TOKEN_MFA': return [3 /*break*/, 2];\n                            case 'SMS' || 'SMS_MFA': return [3 /*break*/, 3];\n                            case 'NOMFA': return [3 /*break*/, 4];\n                        }\n                        return [3 /*break*/, 6];\n                    case 2:\n                        totpMfaSettings = {\n                            PreferredMfa: true,\n                            Enabled: true\n                        };\n                        return [3 /*break*/, 7];\n                    case 3:\n                        smsMfaSettings = {\n                            PreferredMfa: true,\n                            Enabled: true\n                        };\n                        return [3 /*break*/, 7];\n                    case 4:\n                        mfaList = userData['UserMFASettingList'];\n                        return [4 /*yield*/, this._getMfaTypeFromUserData(userData)];\n                    case 5:\n                        currentMFAType = _b.sent();\n                        if (currentMFAType === 'NOMFA') {\n                            return [2 /*return*/, Promise.resolve('No change for mfa type')];\n                        }\n                        else if (currentMFAType === 'SMS_MFA') {\n                            smsMfaSettings = {\n                                PreferredMfa: false,\n                                Enabled: false\n                            };\n                        }\n                        else if (currentMFAType === 'SOFTWARE_TOKEN_MFA') {\n                            totpMfaSettings = {\n                                PreferredMfa: false,\n                                Enabled: false\n                            };\n                        }\n                        else {\n                            return [2 /*return*/, Promise.reject('invalid MFA type')];\n                        }\n                        // if there is a UserMFASettingList in the response\n                        // we need to disable every mfa type in that list\n                        if (mfaList && mfaList.length !== 0) {\n                            // to disable SMS or TOTP if exists in that list\n                            mfaList.forEach(function (mfaType) {\n                                if (mfaType === 'SMS_MFA') {\n                                    smsMfaSettings = {\n                                        PreferredMfa: false,\n                                        Enabled: false\n                                    };\n                                }\n                                else if (mfaType === 'SOFTWARE_TOKEN_MFA') {\n                                    totpMfaSettings = {\n                                        PreferredMfa: false,\n                                        Enabled: false\n                                    };\n                                }\n                            });\n                        }\n                        return [3 /*break*/, 7];\n                    case 6:\n                        logger.debug('no validmfa method provided');\n                        return [2 /*return*/, Promise.reject('no validmfa method provided')];\n                    case 7:\n                        that = this;\n                        return [2 /*return*/, new Promise(function (res, rej) {\n                                user.setUserMfaPreference(smsMfaSettings, totpMfaSettings, function (err, result) {\n                                    if (err) {\n                                        logger.debug('Set user mfa preference error', err);\n                                        return rej(err);\n                                    }\n                                    logger.debug('Set user mfa success', result);\n                                    logger.debug('Caching the latest user data into local');\n                                    // cache the latest result into user data\n                                    user.getUserData(function (err, data) {\n                                        if (err) {\n                                            logger.debug('getting user data failed', err);\n                                            return rej(err);\n                                        }\n                                        else {\n                                            return res(result);\n                                        }\n                                    }, { bypassCache: true });\n                                });\n                            })];\n                }\n            });\n        });\n    };\n    /**\n     * diable SMS\n     * @deprecated\n     * @param {CognitoUser} user - the current user\n     * @return - A promise resolves is success\n     */\n    AuthClass.prototype.disableSMS = function (user) {\n        return new Promise(function (res, rej) {\n            user.disableMFA(function (err, data) {\n                if (err) {\n                    logger.debug('disable mfa failed', err);\n                    rej(err);\n                    return;\n                }\n                logger.debug('disable mfa succeed', data);\n                res(data);\n                return;\n            });\n        });\n    };\n    /**\n     * enable SMS\n     * @deprecated\n     * @param {CognitoUser} user - the current user\n     * @return - A promise resolves is success\n     */\n    AuthClass.prototype.enableSMS = function (user) {\n        return new Promise(function (res, rej) {\n            user.enableMFA(function (err, data) {\n                if (err) {\n                    logger.debug('enable mfa failed', err);\n                    rej(err);\n                    return;\n                }\n                logger.debug('enable mfa succeed', data);\n                res(data);\n                return;\n            });\n        });\n    };\n    /**\n     * Setup TOTP\n     * @param {CognitoUser} user - the current user\n     * @return - A promise resolves with the secret code if success\n     */\n    AuthClass.prototype.setupTOTP = function (user) {\n        return new Promise(function (res, rej) {\n            user.associateSoftwareToken({\n                onFailure: function (err) {\n                    logger.debug('associateSoftwareToken failed', err);\n                    rej(err);\n                    return;\n                },\n                associateSecretCode: function (secretCode) {\n                    logger.debug('associateSoftwareToken sucess', secretCode);\n                    res(secretCode);\n                    return;\n                }\n            });\n        });\n    };\n    /**\n     * verify TOTP setup\n     * @param {CognitoUser} user - the current user\n     * @param {string} challengeAnswer - challenge answer\n     * @return - A promise resolves is success\n     */\n    AuthClass.prototype.verifyTotpToken = function (user, challengeAnswer) {\n        logger.debug('verfication totp token', user, challengeAnswer);\n        return new Promise(function (res, rej) {\n            user.verifySoftwareToken(challengeAnswer, 'My TOTP device', {\n                onFailure: function (err) {\n                    logger.debug('verifyTotpToken failed', err);\n                    rej(err);\n                    return;\n                },\n                onSuccess: function (data) {\n                    logger.debug('verifyTotpToken success', data);\n                    res(data);\n                    return;\n                }\n            });\n        });\n    };\n    /**\n     * Send MFA code to confirm sign in\n     * @param {Object} user - The CognitoUser object\n     * @param {String} code - The confirmation code\n     */\n    AuthClass.prototype.confirmSignIn = function (user, code, mfaType) {\n        var _this = this;\n        if (!code) {\n            return Promise.reject('Code cannot be empty');\n        }\n        var that = this;\n        return new Promise(function (resolve, reject) {\n            user.sendMFACode(code, {\n                onSuccess: function (session) { return __awaiter(_this, void 0, void 0, function () {\n                    var cred, e_3;\n                    return __generator(this, function (_a) {\n                        switch (_a.label) {\n                            case 0:\n                                logger.debug(session);\n                                _a.label = 1;\n                            case 1:\n                                _a.trys.push([1, 4, 5, 6]);\n                                return [4 /*yield*/, core_1.Credentials.clear()];\n                            case 2:\n                                _a.sent();\n                                return [4 /*yield*/, core_1.Credentials.set(session, 'session')];\n                            case 3:\n                                cred = _a.sent();\n                                logger.debug('succeed to get cognito credentials', cred);\n                                return [3 /*break*/, 6];\n                            case 4:\n                                e_3 = _a.sent();\n                                logger.debug('cannot get cognito credentials', e_3);\n                                return [3 /*break*/, 6];\n                            case 5:\n                                that.user = user;\n                                dispatchAuthEvent('signIn', user, user + \" has signed in\");\n                                resolve(user);\n                                return [7 /*endfinally*/];\n                            case 6: return [2 /*return*/];\n                        }\n                    });\n                }); },\n                onFailure: function (err) {\n                    logger.debug('confirm signIn failure', err);\n                    reject(err);\n                }\n            }, mfaType);\n        });\n    };\n    AuthClass.prototype.completeNewPassword = function (user, password, requiredAttributes) {\n        var _this = this;\n        if (!password) {\n            return Promise.reject('Password cannot be empty');\n        }\n        var that = this;\n        return new Promise(function (resolve, reject) {\n            user.completeNewPasswordChallenge(password, requiredAttributes, {\n                onSuccess: function (session) { return __awaiter(_this, void 0, void 0, function () {\n                    var cred, e_4;\n                    return __generator(this, function (_a) {\n                        switch (_a.label) {\n                            case 0:\n                                logger.debug(session);\n                                _a.label = 1;\n                            case 1:\n                                _a.trys.push([1, 4, 5, 6]);\n                                return [4 /*yield*/, core_1.Credentials.clear()];\n                            case 2:\n                                _a.sent();\n                                return [4 /*yield*/, core_1.Credentials.set(session, 'session')];\n                            case 3:\n                                cred = _a.sent();\n                                logger.debug('succeed to get cognito credentials', cred);\n                                return [3 /*break*/, 6];\n                            case 4:\n                                e_4 = _a.sent();\n                                logger.debug('cannot get cognito credentials', e_4);\n                                return [3 /*break*/, 6];\n                            case 5:\n                                that.user = user;\n                                dispatchAuthEvent('signIn', user, user + \" has signed in\");\n                                resolve(user);\n                                return [7 /*endfinally*/];\n                            case 6: return [2 /*return*/];\n                        }\n                    });\n                }); },\n                onFailure: function (err) {\n                    logger.debug('completeNewPassword failure', err);\n                    dispatchAuthEvent('completeNewPassword_failure', err, _this.user + \" failed to complete the new password flow\");\n                    reject(err);\n                },\n                mfaRequired: function (challengeName, challengeParam) {\n                    logger.debug('signIn MFA required');\n                    user['challengeName'] = challengeName;\n                    user['challengeParam'] = challengeParam;\n                    resolve(user);\n                },\n                mfaSetup: function (challengeName, challengeParam) {\n                    logger.debug('signIn mfa setup', challengeName);\n                    user['challengeName'] = challengeName;\n                    user['challengeParam'] = challengeParam;\n                    resolve(user);\n                }\n            });\n        });\n    };\n    /**\n     * Send the answer to a custom challenge\n     * @param {CognitoUser} user - The CognitoUser object\n     * @param {String} challengeResponses - The confirmation code\n     */\n    AuthClass.prototype.sendCustomChallengeAnswer = function (user, challengeResponses) {\n        var _this = this;\n        if (!this.userPool) {\n            return Promise.reject('No userPool');\n        }\n        if (!challengeResponses) {\n            return Promise.reject('Challenge response cannot be empty');\n        }\n        var that = this;\n        return new Promise(function (resolve, reject) {\n            user.sendCustomChallengeAnswer(challengeResponses, _this.authCallbacks(user, resolve, reject));\n        });\n    };\n    /**\n     * Update an authenticated users' attributes\n     * @param {CognitoUser} - The currently logged in user object\n     * @return {Promise}\n     **/\n    AuthClass.prototype.updateUserAttributes = function (user, attributes) {\n        var attributeList = [];\n        var that = this;\n        return new Promise(function (resolve, reject) {\n            that.userSession(user).then(function (session) {\n                for (var key in attributes) {\n                    if (key !== 'sub' &&\n                        key.indexOf('_verified') < 0) {\n                        var attr = {\n                            'Name': key,\n                            'Value': attributes[key]\n                        };\n                        attributeList.push(attr);\n                    }\n                }\n                user.updateAttributes(attributeList, function (err, result) {\n                    if (err) {\n                        return reject(err);\n                    }\n                    else {\n                        return resolve(result);\n                    }\n                });\n            });\n        });\n    };\n    /**\n     * Return user attributes\n     * @param {Object} user - The CognitoUser object\n     * @return - A promise resolves to user attributes if success\n     */\n    AuthClass.prototype.userAttributes = function (user) {\n        var _this = this;\n        return new Promise(function (resolve, reject) {\n            _this.userSession(user).then(function (session) {\n                user.getUserAttributes(function (err, attributes) {\n                    if (err) {\n                        reject(err);\n                    }\n                    else {\n                        resolve(attributes);\n                    }\n                });\n            });\n        });\n    };\n    AuthClass.prototype.verifiedContact = function (user) {\n        var that = this;\n        return this.userAttributes(user)\n            .then(function (attributes) {\n            var attrs = that.attributesToObject(attributes);\n            var unverified = {};\n            var verified = {};\n            if (attrs['email']) {\n                if (attrs['email_verified']) {\n                    verified['email'] = attrs['email'];\n                }\n                else {\n                    unverified['email'] = attrs['email'];\n                }\n            }\n            if (attrs['phone_number']) {\n                if (attrs['phone_number_verified']) {\n                    verified['phone_number'] = attrs['phone_number'];\n                }\n                else {\n                    unverified['phone_number'] = attrs['phone_number'];\n                }\n            }\n            return {\n                verified: verified,\n                unverified: unverified\n            };\n        });\n    };\n    /**\n     * Get current authenticated user\n     * @return - A promise resolves to current authenticated CognitoUser if success\n     */\n    AuthClass.prototype.currentUserPoolUser = function (params) {\n        var _this = this;\n        if (!this.userPool) {\n            return Promise.reject('No userPool');\n        }\n        var that = this;\n        return new Promise(function (res, rej) {\n            _this._storageSync.then(function () {\n                var user = that.userPool.getCurrentUser();\n                if (!user) {\n                    logger.debug('Failed to get user from user pool');\n                    rej('No current user');\n                    return;\n                }\n                // refresh the session if the session expired.\n                user.getSession(function (err, session) {\n                    if (err) {\n                        logger.debug('Failed to get the user session', err);\n                        rej(err);\n                        return;\n                    }\n                    // get user data from Cognito\n                    var bypassCache = params ? params.bypassCache : false;\n                    // validate the token's scope fisrt before calling this function\n                    var _a = session.getAccessToken().decodePayload().scope, scope = _a === void 0 ? '' : _a;\n                    if (scope.split(' ').includes(USER_ADMIN_SCOPE)) {\n                        user.getUserData(function (err, data) {\n                            if (err) {\n                                logger.debug('getting user data failed', err);\n                                // Make sure the user is still valid\n                                if (err.message === 'User is disabled' || err.message === 'User does not exist.') {\n                                    rej(err);\n                                }\n                                else {\n                                    // the error may also be thrown when lack of permissions to get user info etc\n                                    // in that case we just bypass the error\n                                    res(user);\n                                }\n                                return;\n                            }\n                            var preferredMFA = data.PreferredMfaSetting || 'NOMFA';\n                            var attributeList = [];\n                            for (var i = 0; i < data.UserAttributes.length; i++) {\n                                var attribute = {\n                                    Name: data.UserAttributes[i].Name,\n                                    Value: data.UserAttributes[i].Value,\n                                };\n                                var userAttribute = new amazon_cognito_identity_js_1.CognitoUserAttribute(attribute);\n                                attributeList.push(userAttribute);\n                            }\n                            var attributes = that.attributesToObject(attributeList);\n                            Object.assign(user, { attributes: attributes, preferredMFA: preferredMFA });\n                            return res(user);\n                        }, { bypassCache: bypassCache });\n                    }\n                    else {\n                        logger.debug(\"Unable to get the user data because the \" + USER_ADMIN_SCOPE + \" \" +\n                            \"is not in the scopes of the access token\");\n                        return res(user);\n                    }\n                });\n            }).catch(function (e) {\n                logger.debug('Failed to sync cache info into memory', e);\n                return rej(e);\n            });\n        });\n    };\n    /**\n     * Get current authenticated user\n     * @param {CurrentUserOpts} - options for getting the current user\n     * @return - A promise resolves to current authenticated CognitoUser if success\n     */\n    AuthClass.prototype.currentAuthenticatedUser = function (params) {\n        return __awaiter(this, void 0, void 0, function () {\n            var federatedUser, e_5, user, e_6;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        logger.debug('getting current authenticted user');\n                        federatedUser = null;\n                        _a.label = 1;\n                    case 1:\n                        _a.trys.push([1, 3, , 4]);\n                        return [4 /*yield*/, this._storageSync];\n                    case 2:\n                        _a.sent();\n                        return [3 /*break*/, 4];\n                    case 3:\n                        e_5 = _a.sent();\n                        logger.debug('Failed to sync cache info into memory', e_5);\n                        throw e_5;\n                    case 4:\n                        try {\n                            federatedUser = JSON.parse(this._storage.getItem('aws-amplify-federatedInfo')).user;\n                        }\n                        catch (e) {\n                            logger.debug('cannot load federated user from auth storage');\n                        }\n                        if (!federatedUser) return [3 /*break*/, 5];\n                        this.user = federatedUser;\n                        logger.debug('get current authenticated federated user', this.user);\n                        return [2 /*return*/, this.user];\n                    case 5:\n                        logger.debug('get current authenticated userpool user');\n                        user = null;\n                        _a.label = 6;\n                    case 6:\n                        _a.trys.push([6, 8, , 9]);\n                        return [4 /*yield*/, this.currentUserPoolUser(params)];\n                    case 7:\n                        user = _a.sent();\n                        return [3 /*break*/, 9];\n                    case 8:\n                        e_6 = _a.sent();\n                        if (e_6 === 'No userPool') {\n                            logger.error('Cannot get the current user because the user pool is missing. ' +\n                                'Please make sure the Auth module is configured with a valid Cognito User Pool ID');\n                        }\n                        logger.debug('The user is not authenticated by the error', e_6);\n                        throw ('not authenticated');\n                    case 9:\n                        this.user = user;\n                        return [2 /*return*/, this.user];\n                }\n            });\n        });\n    };\n    /**\n     * Get current user's session\n     * @return - A promise resolves to session object if success\n     */\n    AuthClass.prototype.currentSession = function () {\n        var that = this;\n        logger.debug('Getting current session');\n        if (!this.userPool) {\n            return Promise.reject('No userPool');\n        }\n        return new Promise(function (res, rej) {\n            that.currentUserPoolUser().then(function (user) {\n                that.userSession(user).then(function (session) {\n                    res(session);\n                    return;\n                }).catch(function (e) {\n                    logger.debug('Failed to get the current session', e);\n                    rej(e);\n                    return;\n                });\n            }).catch(function (e) {\n                logger.debug('Failed to get the current user', e);\n                rej(e);\n                return;\n            });\n        });\n    };\n    /**\n     * Get the corresponding user session\n     * @param {Object} user - The CognitoUser object\n     * @return - A promise resolves to the session\n     */\n    AuthClass.prototype.userSession = function (user) {\n        if (!user) {\n            logger.debug('the user is null');\n            return Promise.reject('Failed to get the session because the user is empty');\n        }\n        return new Promise(function (resolve, reject) {\n            logger.debug('Getting the session from this user:', user);\n            user.getSession(function (err, session) {\n                if (err) {\n                    logger.debug('Failed to get the session from user', user);\n                    reject(err);\n                    return;\n                }\n                else {\n                    logger.debug('Succeed to get the user session', session);\n                    resolve(session);\n                    return;\n                }\n            });\n        });\n    };\n    /**\n     * Get  authenticated credentials of current user.\n     * @return - A promise resolves to be current user's credentials\n     */\n    AuthClass.prototype.currentUserCredentials = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var that, e_7, federatedInfo;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        that = this;\n                        logger.debug('Getting current user credentials');\n                        _a.label = 1;\n                    case 1:\n                        _a.trys.push([1, 3, , 4]);\n                        return [4 /*yield*/, this._storageSync];\n                    case 2:\n                        _a.sent();\n                        return [3 /*break*/, 4];\n                    case 3:\n                        e_7 = _a.sent();\n                        logger.debug('Failed to sync cache info into memory', e_7);\n                        throw e_7;\n                    case 4:\n                        federatedInfo = null;\n                        try {\n                            federatedInfo = JSON.parse(this._storage.getItem('aws-amplify-federatedInfo'));\n                        }\n                        catch (e) {\n                            logger.debug('failed to get or parse item aws-amplify-federatedInfo', e);\n                        }\n                        if (federatedInfo) {\n                            // refresh the jwt token here if necessary\n                            return [2 /*return*/, core_1.Credentials.refreshFederatedToken(federatedInfo)];\n                        }\n                        else {\n                            return [2 /*return*/, this.currentSession()\n                                    .then(function (session) {\n                                    logger.debug('getting session success', session);\n                                    return core_1.Credentials.set(session, 'session');\n                                }).catch(function (error) {\n                                    logger.debug('getting session failed', error);\n                                    return core_1.Credentials.set(null, 'guest');\n                                })];\n                        }\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    AuthClass.prototype.currentCredentials = function () {\n        logger.debug('getting current credntials');\n        return core_1.Credentials.get();\n    };\n    /**\n     * Initiate an attribute confirmation request\n     * @param {Object} user - The CognitoUser\n     * @param {Object} attr - The attributes to be verified\n     * @return - A promise resolves to callback data if success\n     */\n    AuthClass.prototype.verifyUserAttribute = function (user, attr) {\n        return new Promise(function (resolve, reject) {\n            user.getAttributeVerificationCode(attr, {\n                onSuccess: function () { return resolve(); },\n                onFailure: function (err) { return reject(err); }\n            });\n        });\n    };\n    /**\n     * Confirm an attribute using a confirmation code\n     * @param {Object} user - The CognitoUser\n     * @param {Object} attr - The attribute to be verified\n     * @param {String} code - The confirmation code\n     * @return - A promise resolves to callback data if success\n     */\n    AuthClass.prototype.verifyUserAttributeSubmit = function (user, attr, code) {\n        if (!code) {\n            return Promise.reject('Code cannot be empty');\n        }\n        return new Promise(function (resolve, reject) {\n            user.verifyAttribute(attr, code, {\n                onSuccess: function (data) {\n                    resolve(data);\n                    return;\n                },\n                onFailure: function (err) {\n                    reject(err);\n                    return;\n                }\n            });\n        });\n    };\n    AuthClass.prototype.verifyCurrentUserAttribute = function (attr) {\n        var that = this;\n        return that.currentUserPoolUser()\n            .then(function (user) { return that.verifyUserAttribute(user, attr); });\n    };\n    /**\n     * Confirm current user's attribute using a confirmation code\n     * @param {Object} attr - The attribute to be verified\n     * @param {String} code - The confirmation code\n     * @return - A promise resolves to callback data if success\n     */\n    AuthClass.prototype.verifyCurrentUserAttributeSubmit = function (attr, code) {\n        var that = this;\n        return that.currentUserPoolUser()\n            .then(function (user) { return that.verifyUserAttributeSubmit(user, attr, code); });\n    };\n    AuthClass.prototype.cognitoIdentitySignOut = function (opts, user) {\n        return __awaiter(this, void 0, void 0, function () {\n            var e_8, isSignedInHostedUI;\n            var _this = this;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        _a.trys.push([0, 2, , 3]);\n                        return [4 /*yield*/, this._storageSync];\n                    case 1:\n                        _a.sent();\n                        return [3 /*break*/, 3];\n                    case 2:\n                        e_8 = _a.sent();\n                        logger.debug('Failed to sync cache info into memory', e_8);\n                        throw e_8;\n                    case 3:\n                        isSignedInHostedUI = this._oAuthHandler\n                            && this._storage.getItem('amplify-signin-with-hostedUI') === 'true';\n                        return [2 /*return*/, new Promise(function (res, rej) {\n                                if (opts && opts.global) {\n                                    logger.debug('user global sign out', user);\n                                    // in order to use global signout\n                                    // we must validate the user as an authenticated user by using getSession\n                                    user.getSession(function (err, result) {\n                                        if (err) {\n                                            logger.debug('failed to get the user session', err);\n                                            return rej(err);\n                                        }\n                                        user.globalSignOut({\n                                            onSuccess: function (data) {\n                                                logger.debug('global sign out success');\n                                                if (isSignedInHostedUI) {\n                                                    return _this._oAuthHandler.signOut().then(function () { return res(); });\n                                                }\n                                                else {\n                                                    return res();\n                                                }\n                                            },\n                                            onFailure: function (err) {\n                                                logger.debug('global sign out failed', err);\n                                                return rej(err);\n                                            }\n                                        });\n                                    });\n                                }\n                                else {\n                                    logger.debug('user sign out', user);\n                                    user.signOut();\n                                    if (isSignedInHostedUI) {\n                                        return _this._oAuthHandler.signOut().then(function () { return res(); });\n                                    }\n                                    else {\n                                        return res();\n                                    }\n                                }\n                            })];\n                }\n            });\n        });\n    };\n    /**\n     * Sign out method\n     * @\n     * @return - A promise resolved if success\n     */\n    AuthClass.prototype.signOut = function (opts) {\n        return __awaiter(this, void 0, void 0, function () {\n            var e_9, user;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        _a.trys.push([0, 2, , 3]);\n                        return [4 /*yield*/, this.cleanCachedItems()];\n                    case 1:\n                        _a.sent();\n                        return [3 /*break*/, 3];\n                    case 2:\n                        e_9 = _a.sent();\n                        logger.debug('failed to clear cached items');\n                        return [3 /*break*/, 3];\n                    case 3:\n                        if (!this.userPool) return [3 /*break*/, 7];\n                        user = this.userPool.getCurrentUser();\n                        if (!user) return [3 /*break*/, 5];\n                        return [4 /*yield*/, this.cognitoIdentitySignOut(opts, user)];\n                    case 4:\n                        _a.sent();\n                        return [3 /*break*/, 6];\n                    case 5:\n                        logger.debug('no current Cognito user');\n                        _a.label = 6;\n                    case 6: return [3 /*break*/, 8];\n                    case 7:\n                        logger.debug('no Congito User pool');\n                        _a.label = 8;\n                    case 8:\n                        /**\n                         * Note for future refactor - no reliable way to get username with\n                         * Cognito User Pools vs Identity when federating with Social Providers\n                         * This is why we need a well structured session object that can be inspected\n                         * and information passed back in the message below for Hub dispatch\n                        */\n                        dispatchAuthEvent('signOut', this.user, \"A user has been signed out\");\n                        this.user = null;\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    AuthClass.prototype.cleanCachedItems = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: \n                    // clear cognito cached item\n                    return [4 /*yield*/, core_1.Credentials.clear()];\n                    case 1:\n                        // clear cognito cached item\n                        _a.sent();\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Change a password for an authenticated user\n     * @param {Object} user - The CognitoUser object\n     * @param {String} oldPassword - the current password\n     * @param {String} newPassword - the requested new password\n     * @return - A promise resolves if success\n     */\n    AuthClass.prototype.changePassword = function (user, oldPassword, newPassword) {\n        var _this = this;\n        return new Promise(function (resolve, reject) {\n            _this.userSession(user).then(function (session) {\n                user.changePassword(oldPassword, newPassword, function (err, data) {\n                    if (err) {\n                        logger.debug('change password failure', err);\n                        return reject(err);\n                    }\n                    else {\n                        return resolve(data);\n                    }\n                });\n            });\n        });\n    };\n    /**\n     * Initiate a forgot password request\n     * @param {String} username - the username to change password\n     * @return - A promise resolves if success\n     */\n    AuthClass.prototype.forgotPassword = function (username) {\n        if (!this.userPool) {\n            return Promise.reject('No userPool');\n        }\n        if (!username) {\n            return Promise.reject('Username cannot be empty');\n        }\n        var user = this.createCognitoUser(username);\n        return new Promise(function (resolve, reject) {\n            user.forgotPassword({\n                onSuccess: function () {\n                    resolve();\n                    return;\n                },\n                onFailure: function (err) {\n                    logger.debug('forgot password failure', err);\n                    reject(err);\n                    return;\n                },\n                inputVerificationCode: function (data) {\n                    resolve(data);\n                    return;\n                }\n            });\n        });\n    };\n    /**\n     * Confirm a new password using a confirmation Code\n     * @param {String} username - The username\n     * @param {String} code - The confirmation code\n     * @param {String} password - The new password\n     * @return - A promise that resolves if success\n     */\n    AuthClass.prototype.forgotPasswordSubmit = function (username, code, password) {\n        if (!this.userPool) {\n            return Promise.reject('No userPool');\n        }\n        if (!username) {\n            return Promise.reject('Username cannot be empty');\n        }\n        if (!code) {\n            return Promise.reject('Code cannot be empty');\n        }\n        if (!password) {\n            return Promise.reject('Password cannot be empty');\n        }\n        var user = this.createCognitoUser(username);\n        return new Promise(function (resolve, reject) {\n            user.confirmPassword(code, password, {\n                onSuccess: function () {\n                    resolve();\n                    return;\n                },\n                onFailure: function (err) {\n                    reject(err);\n                    return;\n                }\n            });\n        });\n    };\n    /**\n     * Get user information\n     * @async\n     * @return {Object }- current User's information\n     */\n    AuthClass.prototype.currentUserInfo = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var source, user, attributes, userAttrs, credentials, e_10, info, err_1, user;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        source = core_1.Credentials.getCredSource();\n                        if (!(!source || source === 'aws' || source === 'userPool')) return [3 /*break*/, 9];\n                        return [4 /*yield*/, this.currentUserPoolUser()\n                                .catch(function (err) { return logger.debug(err); })];\n                    case 1:\n                        user = _a.sent();\n                        if (!user) {\n                            return [2 /*return*/, null];\n                        }\n                        _a.label = 2;\n                    case 2:\n                        _a.trys.push([2, 8, , 9]);\n                        return [4 /*yield*/, this.userAttributes(user)];\n                    case 3:\n                        attributes = _a.sent();\n                        userAttrs = this.attributesToObject(attributes);\n                        credentials = null;\n                        _a.label = 4;\n                    case 4:\n                        _a.trys.push([4, 6, , 7]);\n                        return [4 /*yield*/, this.currentCredentials()];\n                    case 5:\n                        credentials = _a.sent();\n                        return [3 /*break*/, 7];\n                    case 6:\n                        e_10 = _a.sent();\n                        logger.debug('Failed to retrieve credentials while getting current user info', e_10);\n                        return [3 /*break*/, 7];\n                    case 7:\n                        info = {\n                            'id': credentials ? credentials.identityId : undefined,\n                            'username': user.getUsername(),\n                            'attributes': userAttrs\n                        };\n                        return [2 /*return*/, info];\n                    case 8:\n                        err_1 = _a.sent();\n                        logger.debug('currentUserInfo error', err_1);\n                        return [2 /*return*/, {}];\n                    case 9:\n                        if (source === 'federated') {\n                            user = this.user;\n                            return [2 /*return*/, user ? user : {}];\n                        }\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    AuthClass.prototype.federatedSignIn = function (providerOrOptions, response, user) {\n        return __awaiter(this, void 0, void 0, function () {\n            var options, provider, client_id, redirect_uri, provider, loggedInUser, e_11, token, identity_id, expires_at, credentials, currentUser;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!this._config.identityPoolId && !this._config.userPoolId) {\n                            throw new Error(\"Federation requires either a User Pool or Identity Pool in config\");\n                        }\n                        // Ensure backwards compatability\n                        if (typeof providerOrOptions === 'undefined') {\n                            if (this._config.identityPoolId && !this._config.userPoolId) {\n                                throw new Error(\"Federation with Identity Pools requires tokens passed as arguments\");\n                            }\n                        }\n                        if (!(types_1.isFederatedSignInOptions(providerOrOptions)\n                            || types_1.isFederatedSignInOptionsCustom(providerOrOptions)\n                            || typeof providerOrOptions === 'undefined')) return [3 /*break*/, 1];\n                        options = providerOrOptions || { provider: CognitoHostedUIIdentityProvider.Cognito };\n                        provider = types_1.isFederatedSignInOptions(options)\n                            ? options.provider\n                            : options.customProvider;\n                        if (this._config.userPoolId) {\n                            client_id = types_1.isCognitoHostedOpts(this._config.oauth)\n                                ? this._config.userPoolWebClientId\n                                : this._config.oauth.clientID;\n                            redirect_uri = types_1.isCognitoHostedOpts(this._config.oauth)\n                                ? this._config.oauth.redirectSignIn\n                                : this._config.oauth.redirectUri;\n                            this._oAuthHandler.oauthSignIn(this._config.oauth.responseType, this._config.oauth.domain, redirect_uri, client_id, provider);\n                        }\n                        return [3 /*break*/, 8];\n                    case 1:\n                        provider = providerOrOptions;\n                        _a.label = 2;\n                    case 2:\n                        _a.trys.push([2, 4, , 5]);\n                        return [4 /*yield*/, this.currentAuthenticatedUser()];\n                    case 3:\n                        loggedInUser = _a.sent();\n                        logger.warn(\"There is already a signed in user: \" + loggedInUser + \" in your app.\\n                You should not call Auth.federatedSignIn method again as it may cause unexpected behavior.\");\n                        return [3 /*break*/, 5];\n                    case 4:\n                        e_11 = _a.sent();\n                        return [3 /*break*/, 5];\n                    case 5:\n                        token = response.token, identity_id = response.identity_id, expires_at = response.expires_at;\n                        return [4 /*yield*/, core_1.Credentials.set({ provider: provider, token: token, identity_id: identity_id, user: user, expires_at: expires_at }, 'federation')];\n                    case 6:\n                        credentials = _a.sent();\n                        return [4 /*yield*/, this.currentAuthenticatedUser()];\n                    case 7:\n                        currentUser = _a.sent();\n                        dispatchAuthEvent('signIn', currentUser, \"A user \" + currentUser.username + \" has been signed in\");\n                        logger.debug('federated sign in credentials', credentials);\n                        return [2 /*return*/, credentials];\n                    case 8: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Used to complete the OAuth flow with or without the Cognito Hosted UI\n     * @param {String} URL - optional parameter for customers to pass in the response URL\n     */\n    AuthClass.prototype._handleAuthResponse = function (URL) {\n        return __awaiter(this, void 0, void 0, function () {\n            var currentUrl, hasCodeOrError, hasTokenOrError, _a, accessToken, idToken, refreshToken, session, credentials, currentUser, err_2;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        if (!this._config.userPoolId) {\n                            throw new Error(\"OAuth responses require a User Pool defined in config\");\n                        }\n                        currentUrl = URL || (core_1.JS.browserOrNode().isBrowser ? window.location.href : null);\n                        hasCodeOrError = !!(url_1.parse(currentUrl).query || '')\n                            .split('&')\n                            .map(function (entry) { return entry.split('='); })\n                            .find(function (_a) {\n                            var k = _a[0];\n                            return k === 'code' || k === 'error';\n                        });\n                        hasTokenOrError = !!(url_1.parse(currentUrl).hash || '#')\n                            .substr(1)\n                            .split('&')\n                            .map(function (entry) { return entry.split('='); })\n                            .find(function (_a) {\n                            var k = _a[0];\n                            return k === 'access_token' || k === 'error';\n                        });\n                        if (!(hasCodeOrError || hasTokenOrError)) return [3 /*break*/, 6];\n                        _b.label = 1;\n                    case 1:\n                        _b.trys.push([1, 5, , 6]);\n                        return [4 /*yield*/, this._oAuthHandler.handleAuthResponse(currentUrl)];\n                    case 2:\n                        _a = _b.sent(), accessToken = _a.accessToken, idToken = _a.idToken, refreshToken = _a.refreshToken;\n                        session = new amazon_cognito_identity_js_1.CognitoUserSession({\n                            IdToken: new amazon_cognito_identity_js_1.CognitoIdToken({ IdToken: idToken }),\n                            RefreshToken: new amazon_cognito_identity_js_1.CognitoRefreshToken({ RefreshToken: refreshToken }),\n                            AccessToken: new amazon_cognito_identity_js_1.CognitoAccessToken({ AccessToken: accessToken })\n                        });\n                        credentials = void 0;\n                        if (!this._config.identityPoolId) return [3 /*break*/, 4];\n                        return [4 /*yield*/, core_1.Credentials.set(session, 'session')];\n                    case 3:\n                        credentials = _b.sent();\n                        logger.debug('AWS credentials', credentials);\n                        _b.label = 4;\n                    case 4:\n                        currentUser = this.createCognitoUser(session.getIdToken().decodePayload()['cognito:username']);\n                        dispatchAuthEvent('signIn', currentUser, \"A user \" + currentUser.getUsername() + \" has been signed in\");\n                        dispatchAuthEvent('cognitoHostedUI', currentUser, \"A user \" + currentUser.getUsername() + \" has been signed in via Cognito Hosted UI\");\n                        // This calls cacheTokens() in Cognito SDK\n                        currentUser.setSignInUserSession(session);\n                        //#endregion\n                        if (window && typeof window.history !== 'undefined') {\n                            window.history.replaceState({}, null, this._config.oauth.redirectSignIn);\n                        }\n                        return [2 /*return*/, credentials];\n                    case 5:\n                        err_2 = _b.sent();\n                        logger.debug(\"Error in cognito hosted auth response\", err_2);\n                        dispatchAuthEvent('signIn_failure', err_2, \"The OAuth response flow failed\");\n                        dispatchAuthEvent('cognitoHostedUI_failure', err_2, \"A failure occurred when returning to the Cognito Hosted UI\");\n                        throw err_2;\n                    case 6: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Compact version of credentials\n     * @param {Object} credentials\n     * @return {Object} - Credentials\n     */\n    AuthClass.prototype.essentialCredentials = function (credentials) {\n        return {\n            accessKeyId: credentials.accessKeyId,\n            sessionToken: credentials.sessionToken,\n            secretAccessKey: credentials.secretAccessKey,\n            identityId: credentials.identityId,\n            authenticated: credentials.authenticated\n        };\n    };\n    AuthClass.prototype.attributesToObject = function (attributes) {\n        var obj = {};\n        if (attributes) {\n            attributes.map(function (attribute) {\n                if (attribute.Value === 'true') {\n                    obj[attribute.Name] = true;\n                }\n                else if (attribute.Value === 'false') {\n                    obj[attribute.Name] = false;\n                }\n                else {\n                    obj[attribute.Name] = attribute.Value;\n                }\n            });\n        }\n        return obj;\n    };\n    AuthClass.prototype.createCognitoUser = function (username) {\n        var userData = {\n            Username: username,\n            Pool: this.userPool,\n        };\n        userData.Storage = this._storage;\n        var authenticationFlowType = this._config.authenticationFlowType;\n        var user = new amazon_cognito_identity_js_1.CognitoUser(userData);\n        if (authenticationFlowType) {\n            user.setAuthenticationFlowType(authenticationFlowType);\n        }\n        return user;\n    };\n    return AuthClass;\n}());\nexports.default = AuthClass;\n"},"sourceMaps":{"js":{"version":3,"file":"Auth.js","sourceRoot":"","sources":["../src/Auth.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright 2017-2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"). You may not use this file except in compliance with\n * the License. A copy of the License is located at\n *\n *     http://aws.amazon.com/apache2.0/\n *\n * or in the \"license\" file accompanying this file. This file is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions\n * and limitations under the License.\n */\n\nimport {\n    AuthOptions,\n    FederatedResponse,\n    SignUpParams,\n    FederatedUser,\n    ConfirmSignUpOptions,\n    SignOutOpts,\n    CurrentUserOpts,\n    GetPreferredMFAOpts,\n    SignInOpts,\n    isUsernamePasswordOpts,\n    isCognitoHostedOpts,\n    isFederatedSignInOptions,\n    isFederatedSignInOptionsCustom,\n    FederatedSignInOptionsCustom,\n    LegacyProvider,\n    FederatedSignInOptions,\n    AwsCognitoOAuthOpts\n} from './types';\n\nimport {\n    AWS,\n    ConsoleLogger as Logger,\n    Constants,\n    Hub,\n    JS,\n    Parser,\n    Credentials,\n    StorageHelper,\n    ICredentials,\n    Platform\n} from '@aws-amplify/core';\nimport {\n    CookieStorage,\n    CognitoUserPool,\n    AuthenticationDetails,\n    ICognitoUserPoolData,\n    ICognitoUserData,\n    ISignUpResult,\n    CognitoUser,\n    MFAOption,\n    CognitoUserSession,\n    IAuthenticationCallback,\n    ICognitoUserAttributeData,\n    CognitoUserAttribute,\n    CognitoIdToken,\n    CognitoRefreshToken,\n    CognitoAccessToken\n} from 'amazon-cognito-identity-js';\n\nimport { parse } from 'url';\nimport OAuth from './OAuth/OAuth';\nimport { default as urlListener } from './urlListener';\n\nconst logger = new Logger('AuthClass');\nconst USER_ADMIN_SCOPE = 'aws.cognito.signin.user.admin';\n\nconst AMPLIFY_SYMBOL = ((typeof Symbol !== 'undefined' && typeof Symbol.for === 'function') ?\n    Symbol.for('amplify_default') : '@@amplify_default') as Symbol;\n\nconst dispatchAuthEvent = (event:string, data:any, message:string) => {\n    Hub.dispatch('auth', { event, data, message }, 'Auth', AMPLIFY_SYMBOL);\n};\n\nexport enum CognitoHostedUIIdentityProvider {\n    Cognito = 'COGNITO',\n    Google = 'Google',\n    Facebook = 'Facebook',\n    Amazon = 'LoginWithAmazon',\n}\n\n/**\n* Provide authentication steps\n*/\nexport default class AuthClass {\n    private _config: AuthOptions;\n    private userPool = null;\n    private user: any = null;\n    private _oAuthHandler: OAuth;\n    private _storage;\n    private _storageSync;\n\n    /**\n     * Initialize Auth with AWS configurations\n     * @param {Object} config - Configuration of the Auth\n     */\n    constructor(config: AuthOptions) {\n        this.configure(config);\n\n        this.currentUserCredentials = this.currentUserCredentials.bind(this);\n\n        if (AWS.config) {\n            AWS.config.update({ customUserAgent: Constants.userAgent });\n        } else {\n            logger.warn('No AWS.config');\n        }\n\n        Hub.listen('auth', ({ payload }) => {\n            const { event } = payload;\n            switch (event) {\n                case 'signIn':\n                    this._storage.setItem('amplify-signin-with-hostedUI', 'false');\n                    break;\n                case 'signOut':\n                    this._storage.removeItem('amplify-signin-with-hostedUI');\n                    break;\n                case 'cognitoHostedUI':\n                    this._storage.setItem('amplify-signin-with-hostedUI', 'true');\n                    break;\n            }\n        });\n    }\n\n    public getModuleName() {\n        return 'Auth';\n    }\n\n    configure(config) {\n        if (!config) return this._config || {};\n        logger.debug('configure Auth');\n        const conf = Object.assign({}, this._config, Parser.parseMobilehubConfig(config).Auth, config);\n        this._config = conf;\n        const {\n            userPoolId,\n            userPoolWebClientId,\n            cookieStorage,\n            oauth,\n            region,\n            identityPoolId,\n            mandatorySignIn,\n            refreshHandlers,\n            identityPoolRegion\n        } = this._config;\n\n        if (!this._config.storage) {\n            // backward compatbility\n            if (cookieStorage) this._storage = new CookieStorage(cookieStorage);\n            else {\n                this._storage = new StorageHelper().getStorage();\n            }\n        } else {\n            if (JS.isEmpty(this._config.storage)) {\n                logger.error('The storage in the Auth config can not be empty!');\n                throw new Error('Empty storage object');\n            }\n            this._storage = this._config.storage;\n        }\n\n        this._storageSync = Promise.resolve();\n        if (typeof this._storage['sync'] === 'function') {\n            this._storageSync = this._storage['sync']();\n        }\n\n        if (userPoolId) {\n            const userPoolData: ICognitoUserPoolData = {\n                UserPoolId: userPoolId,\n                ClientId: userPoolWebClientId,\n            };\n            userPoolData.Storage = this._storage;\n\n            this.userPool = new CognitoUserPool(userPoolData);\n        }\n\n        Credentials.configure({\n            mandatorySignIn,\n            region: identityPoolRegion || region,\n            userPoolId,\n            identityPoolId,\n            refreshHandlers,\n            storage: this._storage\n        });\n\n        // initiailize cognitoauth client if hosted ui options provided\n        // to keep backward compatibility:\n        const cognitoHostedUIConfig = oauth? (isCognitoHostedOpts(this._config.oauth)\n            ? oauth : (<any>oauth).awsCognito)\n            : undefined;\n\n        if (cognitoHostedUIConfig) {\n            const cognitoAuthParams = Object.assign(\n                {\n                    cognitoClientId: userPoolWebClientId,\n                    UserPoolId: userPoolId,\n                    domain: cognitoHostedUIConfig['domain'],\n                    scopes: cognitoHostedUIConfig['scope'],\n                    redirectSignIn: cognitoHostedUIConfig['redirectSignIn'],\n                    redirectSignOut: cognitoHostedUIConfig['redirectSignOut'],\n                    responseType: cognitoHostedUIConfig['responseType'],\n                    Storage: this._storage,\n                    urlOpener: cognitoHostedUIConfig['urlOpener']\n                },\n                cognitoHostedUIConfig['options']\n            );\n\n            this._oAuthHandler = new OAuth({\n                scopes: cognitoAuthParams.scopes,\n                config: cognitoAuthParams,\n                cognitoClientId: cognitoAuthParams.cognitoClientId\n            });\n\n            // **NOTE** - Remove this in a future major release as it is a breaking change\n            urlListener(({ url }) => {\n                this._handleAuthResponse(url);\n            });\n        }\n\n        dispatchAuthEvent(\n            'configured',\n            null,\n            `The Auth category has been configured successfully`\n        );\n        return this._config;\n    }\n\n    /**\n     * Sign up with username, password and other attrbutes like phone, email\n     * @param {String | object} params - The user attirbutes used for signin\n     * @param {String[]} restOfAttrs - for the backward compatability\n     * @return - A promise resolves callback data if success\n     */\n    public signUp(params: string | SignUpParams, ...restOfAttrs: string[]): Promise<ISignUpResult> {\n        if (!this.userPool) { return Promise.reject('No userPool'); }\n\n        let username: string = null;\n        let password: string = null;\n        const attributes: object[] = [];\n        let validationData: object[] = null;\n        if (params && typeof params === 'string') {\n            username = params;\n            password = restOfAttrs ? restOfAttrs[0] : null;\n            const email: string = restOfAttrs ? restOfAttrs[1] : null;\n            const phone_number: string = restOfAttrs ? restOfAttrs[2] : null;\n            if (email) attributes.push({ Name: 'email', Value: email });\n            if (phone_number) attributes.push({ Name: 'phone_number', Value: phone_number });\n        } else if (params && typeof params === 'object') {\n            username = params['username'];\n            password = params['password'];\n            const attrs = params['attributes'];\n            if (attrs) {\n                Object.keys(attrs).map(key => {\n                    const ele: object = { Name: key, Value: attrs[key] };\n                    attributes.push(ele);\n                });\n            }\n            validationData = params['validationData'] || null;\n        } else {\n            return Promise.reject('The first parameter should either be non-null string or object');\n        }\n\n        if (!username) { return Promise.reject('Username cannot be empty'); }\n        if (!password) { return Promise.reject('Password cannot be empty'); }\n\n        logger.debug('signUp attrs:', attributes);\n        logger.debug('signUp validation data:', validationData);\n\n\n        return new Promise((resolve, reject) => {\n            this.userPool.signUp(username, password, attributes, validationData, (err, data) => {\n                if (err) {\n                    dispatchAuthEvent(\n                        'signUp_failure',\n                        err,\n                        `${username} failed to signup`\n                    );\n                    reject(err);\n                } else {\n                    dispatchAuthEvent(\n                        'signUp',\n                        data,\n                        `${username} has signed up successfully`\n                    );\n                    resolve(data);\n                }\n            });\n        });\n    }\n\n    /**\n     * Send the verfication code to confirm sign up\n     * @param {String} username - The username to be confirmed\n     * @param {String} code - The verification code\n     * @param {ConfirmSignUpOptions} options - other options for confirm signup\n     * @return - A promise resolves callback data if success\n     */\n    public confirmSignUp(username: string, code: string, options?: ConfirmSignUpOptions): Promise<any> {\n        if (!this.userPool) { return Promise.reject('No userPool'); }\n        if (!username) { return Promise.reject('Username cannot be empty'); }\n        if (!code) { return Promise.reject('Code cannot be empty'); }\n\n        const user = this.createCognitoUser(username);\n        const forceAliasCreation = options && typeof options.forceAliasCreation === 'boolean'\n            ? options.forceAliasCreation : true;\n\n        return new Promise((resolve, reject) => {\n            user.confirmRegistration(code, forceAliasCreation, (err, data) => {\n                if (err) { reject(err); } else { resolve(data); }\n            });\n        });\n    }\n\n    /**\n     * Resend the verification code\n     * @param {String} username - The username to be confirmed\n     * @return - A promise resolves data if success\n     */\n    public resendSignUp(username: string): Promise<string> {\n        if (!this.userPool) { return Promise.reject('No userPool'); }\n        if (!username) { return Promise.reject('Username cannot be empty'); }\n\n        const user = this.createCognitoUser(username);\n        return new Promise((resolve, reject) => {\n            user.resendConfirmationCode((err, data) => {\n                if (err) { reject(err); } else { resolve(data); }\n            });\n        });\n    }\n\n    /**\n     * Sign in\n     * @param {String | SignInOpts} usernameOrSignInOpts - The username to be signed in or the sign in options\n     * @param {String} password - The password of the username\n     * @return - A promise resolves the CognitoUser\n     */\n    public signIn(usernameOrSignInOpts: string | SignInOpts, pw?: string): Promise<CognitoUser | any> {\n        if (!this.userPool) { return Promise.reject('No userPool'); }\n        let username = null;\n        let password = null;\n        let validationData = {};\n        // for backward compatibility\n        if (typeof usernameOrSignInOpts === 'string') {\n            username = usernameOrSignInOpts;\n            password = pw;\n        } else if (isUsernamePasswordOpts(usernameOrSignInOpts)) {\n            if (typeof pw !== 'undefined') {\n                logger.warn('The password should be defined under the first parameter object!');\n            }\n            username = usernameOrSignInOpts.username;\n            password = usernameOrSignInOpts.password;\n            validationData = usernameOrSignInOpts.validationData;\n        } else {\n            return Promise.reject(new Error('The username should either be a string or one of the sign in types'));\n        }\n        if (!username) { return Promise.reject('Username cannot be empty'); }\n        const authDetails = new AuthenticationDetails({\n            Username: username,\n            Password: password,\n            ValidationData: validationData\n        });\n        if (password) {\n            return this.signInWithPassword(authDetails);\n        } else {\n            return this.signInWithoutPassword(authDetails);\n        }\n    }\n\n    /**\n     * Return an object with the authentication callbacks\n     * @param {CognitoUser} user - the cognito user object\n     * @param {} resolve - function called when resolving the current step\n     * @param {} reject - function called when rejecting the current step\n     * @return - an object with the callback methods for user authentication\n     */\n    private authCallbacks(\n        user: CognitoUser,\n        resolve: (value?: CognitoUser | any) => void, reject: (value?: any) => void\n    ): IAuthenticationCallback {\n        const that = this;\n        return {\n            onSuccess: async (session) => {\n                logger.debug(session);\n                delete (user['challengeName']);\n                delete (user['challengeParam']);\n                try {\n                    await Credentials.clear();\n                    const cred = await Credentials.set(session, 'session');\n                    logger.debug('succeed to get cognito credentials', cred);\n                } catch (e) {\n                    logger.debug('cannot get cognito credentials', e);\n                } finally {\n                try {\n                        // In order to get user attributes and MFA methods\n                        // We need to trigger currentUserPoolUser again\n                        const currentUser = await this.currentUserPoolUser();\n                        that.user = currentUser;\n                        dispatchAuthEvent(\n                        'signIn',\n                        currentUser,\n                        `A user ${user.getUsername()} has been signed in`\n                    );\n                        resolve(currentUser);\n                    } catch (e) {\n                        logger.error('Failed to get the signed in user', e);\n                        reject(e);\n                    }\n                }\n            },\n            onFailure: (err) => {\n                logger.debug('signIn failure', err);\n                dispatchAuthEvent(\n                    'signIn_failure',\n                    err,\n                    `${user.getUsername()} failed to signin`\n                );\n                reject(err);\n            },\n            customChallenge: (challengeParam) => {\n                logger.debug('signIn custom challenge answer required');\n                user['challengeName'] = 'CUSTOM_CHALLENGE';\n                user['challengeParam'] = challengeParam;\n                resolve(user);\n            },\n            mfaRequired: (challengeName, challengeParam) => {\n                logger.debug('signIn MFA required');\n                user['challengeName'] = challengeName;\n                user['challengeParam'] = challengeParam;\n                resolve(user);\n            },\n            mfaSetup: (challengeName, challengeParam) => {\n                logger.debug('signIn mfa setup', challengeName);\n                user['challengeName'] = challengeName;\n                user['challengeParam'] = challengeParam;\n                resolve(user);\n            },\n            newPasswordRequired: (userAttributes, requiredAttributes) => {\n                logger.debug('signIn new password');\n                user['challengeName'] = 'NEW_PASSWORD_REQUIRED';\n                user['challengeParam'] = {\n                    userAttributes,\n                    requiredAttributes\n                };\n                resolve(user);\n            },\n            totpRequired: (challengeName, challengeParam) => {\n                logger.debug('signIn totpRequired');\n                user['challengeName'] = challengeName;\n                user['challengeParam'] = challengeParam;\n                resolve(user);\n            },\n            selectMFAType: (challengeName, challengeParam) => {\n                logger.debug('signIn selectMFAType', challengeName);\n                user['challengeName'] = challengeName;\n                user['challengeParam'] = challengeParam;\n                resolve(user);\n            }\n        };\n    }\n\n    /**\n     * Sign in with a password\n     * @private\n     * @param {AuthenticationDetails} authDetails - the user sign in data\n     * @return - A promise resolves the CognitoUser object if success or mfa required\n     */\n    private signInWithPassword(authDetails: AuthenticationDetails): Promise<CognitoUser | any> {\n        const user = this.createCognitoUser(authDetails.getUsername());\n\n        return new Promise((resolve, reject) => {\n            user.authenticateUser(authDetails, this.authCallbacks(user, resolve, reject));\n        });\n    }\n\n    /**\n     * Sign in without a password\n     * @private\n     * @param {AuthenticationDetails} authDetails - the user sign in data\n     * @return - A promise resolves the CognitoUser object if success or mfa required\n     */\n    private signInWithoutPassword(authDetails: AuthenticationDetails): Promise<CognitoUser | any> {\n        const user = this.createCognitoUser(authDetails.getUsername());\n        user.setAuthenticationFlowType('CUSTOM_AUTH');\n\n        return new Promise((resolve, reject) => {\n            user.initiateAuth(authDetails, this.authCallbacks(user, resolve, reject));\n        });\n    }\n\n    /**\n     * get user current preferred mfa option\n     * this method doesn't work with totp, we need to deprecate it.\n     * @deprecated\n     * @param {CognitoUser} user - the current user\n     * @return - A promise resolves the current preferred mfa option if success\n     */\n    public getMFAOptions(user: CognitoUser | any): Promise<MFAOption[]> {\n        return new Promise((res, rej) => {\n            user.getMFAOptions((err, mfaOptions) => {\n                if (err) {\n                    logger.debug('get MFA Options failed', err);\n                    rej(err);\n                    return;\n                }\n                logger.debug('get MFA options success', mfaOptions);\n                res(mfaOptions);\n                return;\n            });\n        });\n    }\n\n    /**\n     * get preferred mfa method\n     * @param {CognitoUser} user - the current cognito user\n     * @param {GetPreferredMFAOpts} params - options for getting the current user preferred MFA\n     */\n    public getPreferredMFA(user: CognitoUser | any, params?: GetPreferredMFAOpts): Promise<string> {\n        const that = this;\n        return new Promise((res, rej) => {\n            const bypassCache = params? params.bypassCache: false;\n            user.getUserData(\n                (err, data) => {\n                    if (err) {\n                        logger.debug('getting preferred mfa failed', err);\n                        rej(err);\n                        return;\n                    }\n\n                    const mfaType = that._getMfaTypeFromUserData(data);\n                    if (!mfaType) {\n                        rej('invalid MFA Type');\n                        return;\n                    } else {\n                        res(mfaType);\n                        return;\n                    }\n                },\n                { bypassCache }\n            );\n        });\n    }\n\n    private _getMfaTypeFromUserData(data) {\n        let ret = null;\n        const preferredMFA = data.PreferredMfaSetting;\n        // if the user has used Auth.setPreferredMFA() to setup the mfa type\n        // then the \"PreferredMfaSetting\" would exist in the response\n        if (preferredMFA) {\n            ret = preferredMFA;\n        } else {\n            // if mfaList exists but empty, then its noMFA\n            const mfaList = data.UserMFASettingList;\n            if (!mfaList) {\n                // if SMS was enabled by using Auth.enableSMS(),\n                // the response would contain MFAOptions\n                // as for now Cognito only supports for SMS, so we will say it is 'SMS_MFA'\n                // if it does not exist, then it should be NOMFA\n                const MFAOptions = data.MFAOptions;\n                if (MFAOptions) {\n                    ret = 'SMS_MFA';\n                } else {\n                    ret = 'NOMFA';\n                }\n            } else if (mfaList.length === 0) {\n                ret = 'NOMFA';\n            } else {\n                logger.debug('invalid case for getPreferredMFA', data);\n            }\n        }\n        return ret;\n    }\n\n    private _getUserData(user, params) {\n        return new Promise((res, rej) => {\n            user.getUserData(\n                (err, data) => {\n                    if (err) {\n                        logger.debug('getting user data failed', err);\n                        rej(err);\n                        return;\n                    } else {\n                        res(data);\n                        return;\n                    }\n                },\n                params\n            );\n        });\n\n    }\n\n    /**\n     * set preferred MFA method\n     * @param {CognitoUser} user - the current Cognito user\n     * @param {string} mfaMethod - preferred mfa method\n     * @return - A promise resolve if success\n     */\n    public async setPreferredMFA(user: CognitoUser | any, mfaMethod: 'TOTP' | 'SMS' | 'NOMFA'): Promise<string> {\n        const userData = await this._getUserData(user, { bypassCache: true });\n        let smsMfaSettings = null;\n        let totpMfaSettings = null;\n\n        switch (mfaMethod) {\n            case 'TOTP' || 'SOFTWARE_TOKEN_MFA':\n                totpMfaSettings = {\n                    PreferredMfa: true,\n                    Enabled: true\n                };\n                break;\n            case 'SMS' || 'SMS_MFA':\n                smsMfaSettings = {\n                    PreferredMfa: true,\n                    Enabled: true\n                };\n                break;\n            case 'NOMFA':\n                const mfaList = userData['UserMFASettingList'];\n                const currentMFAType = await this._getMfaTypeFromUserData(userData);\n                if (currentMFAType === 'NOMFA') {\n                    return Promise.resolve('No change for mfa type');\n                } else if (currentMFAType === 'SMS_MFA') {\n                    smsMfaSettings = {\n                        PreferredMfa: false,\n                        Enabled: false\n                    };\n                } else if (currentMFAType === 'SOFTWARE_TOKEN_MFA') {\n                    totpMfaSettings = {\n                        PreferredMfa: false,\n                        Enabled: false\n                    };\n                } else {\n                    return Promise.reject('invalid MFA type');\n                }\n                // if there is a UserMFASettingList in the response\n                // we need to disable every mfa type in that list\n                if (mfaList && mfaList.length !== 0) {\n                    // to disable SMS or TOTP if exists in that list\n                    mfaList.forEach(mfaType => {\n                        if (mfaType === 'SMS_MFA') {\n                            smsMfaSettings = {\n                                PreferredMfa: false,\n                                Enabled: false\n                            };\n                        } else if (mfaType === 'SOFTWARE_TOKEN_MFA') {\n                            totpMfaSettings = {\n                                PreferredMfa: false,\n                                Enabled: false\n                            };\n                        }\n                    });\n                }\n                break;\n            default:\n                logger.debug('no validmfa method provided');\n                return Promise.reject('no validmfa method provided');\n        }\n\n        const that = this;\n        return new Promise<string>((res, rej) => {\n            user.setUserMfaPreference(smsMfaSettings, totpMfaSettings, (err, result) => {\n                if (err) {\n                    logger.debug('Set user mfa preference error', err);\n                    return rej(err);\n                }\n                logger.debug('Set user mfa success', result);\n                logger.debug('Caching the latest user data into local');\n                // cache the latest result into user data\n                user.getUserData(\n                    (err, data) => {\n                        if (err) {\n                            logger.debug('getting user data failed', err);\n                            return rej(err);\n                        } else {\n                            return res(result);\n                        }\n                    },\n                    {bypassCache: true}\n                );\n            });\n        });\n    }\n\n    /**\n     * diable SMS\n     * @deprecated\n     * @param {CognitoUser} user - the current user\n     * @return - A promise resolves is success\n     */\n    public disableSMS(user: CognitoUser): Promise<string> {\n        return new Promise((res, rej) => {\n            user.disableMFA((err, data) => {\n                if (err) {\n                    logger.debug('disable mfa failed', err);\n                    rej(err);\n                    return;\n                }\n                logger.debug('disable mfa succeed', data);\n                res(data);\n                return;\n            });\n        });\n    }\n\n    /**\n     * enable SMS\n     * @deprecated\n     * @param {CognitoUser} user - the current user\n     * @return - A promise resolves is success\n     */\n    public enableSMS(user: CognitoUser): Promise<string> {\n        return new Promise((res, rej) => {\n            user.enableMFA((err, data) => {\n                if (err) {\n                    logger.debug('enable mfa failed', err);\n                    rej(err);\n                    return;\n                }\n                logger.debug('enable mfa succeed', data);\n                res(data);\n                return;\n            });\n        });\n    }\n\n    /**\n     * Setup TOTP\n     * @param {CognitoUser} user - the current user\n     * @return - A promise resolves with the secret code if success\n     */\n    public setupTOTP(user: CognitoUser | any): Promise<string> {\n        return new Promise((res, rej) => {\n            user.associateSoftwareToken({\n                onFailure: (err) => {\n                    logger.debug('associateSoftwareToken failed', err);\n                    rej(err);\n                    return;\n                },\n                associateSecretCode: (secretCode) => {\n                    logger.debug('associateSoftwareToken sucess', secretCode);\n                    res(secretCode);\n                    return;\n                }\n            });\n        });\n    }\n\n    /**\n     * verify TOTP setup\n     * @param {CognitoUser} user - the current user\n     * @param {string} challengeAnswer - challenge answer\n     * @return - A promise resolves is success\n     */\n    public verifyTotpToken(user: CognitoUser | any, challengeAnswer: string): Promise<CognitoUserSession> {\n        logger.debug('verfication totp token', user, challengeAnswer);\n        return new Promise((res, rej) => {\n            user.verifySoftwareToken(challengeAnswer, 'My TOTP device', {\n                onFailure: (err) => {\n                    logger.debug('verifyTotpToken failed', err);\n                    rej(err);\n                    return;\n                },\n                onSuccess: (data) => {\n                    logger.debug('verifyTotpToken success', data);\n                    res(data);\n                    return;\n                }\n            });\n        });\n    }\n\n    /**\n     * Send MFA code to confirm sign in\n     * @param {Object} user - The CognitoUser object\n     * @param {String} code - The confirmation code\n     */\n    public confirmSignIn(\n        user: CognitoUser | any,\n        code: string,\n        mfaType?: 'SMS_MFA' | 'SOFTWARE_TOKEN_MFA' | null\n    ): Promise<CognitoUser | any> {\n        if (!code) { return Promise.reject('Code cannot be empty'); }\n\n        const that = this;\n        return new Promise((resolve, reject) => {\n            user.sendMFACode(\n                code, {\n                    onSuccess: async (session) => {\n                        logger.debug(session);\n                        try {\n                            await Credentials.clear();\n                            const cred = await Credentials.set(session, 'session');\n                            logger.debug('succeed to get cognito credentials', cred);\n                        } catch (e) {\n                            logger.debug('cannot get cognito credentials', e);\n                        } finally {\n                            that.user = user;\n\n                            dispatchAuthEvent(\n                                'signIn',\n                                user,\n                                `${user} has signed in`\n                            );\n                            resolve(user);\n                        }\n                    },\n                    onFailure: (err) => {\n                        logger.debug('confirm signIn failure', err);\n                        reject(err);\n                    }\n                },\n                mfaType);\n        });\n    }\n\n    public completeNewPassword(\n        user: CognitoUser | any,\n        password: string,\n        requiredAttributes: any\n    ): Promise<CognitoUser | any> {\n        if (!password) { return Promise.reject('Password cannot be empty'); }\n\n        const that = this;\n        return new Promise((resolve, reject) => {\n            user.completeNewPasswordChallenge(password, requiredAttributes, {\n                onSuccess: async (session) => {\n                    logger.debug(session);\n                    try {\n                        await Credentials.clear();\n                        const cred = await Credentials.set(session, 'session');\n                        logger.debug('succeed to get cognito credentials', cred);\n                    } catch (e) {\n                        logger.debug('cannot get cognito credentials', e);\n                    } finally {\n                        that.user = user;\n                        dispatchAuthEvent(\n                            'signIn',\n                            user, `${user} has signed in`\n                        );\n                        resolve(user);\n                    }\n                },\n                onFailure: (err) => {\n                    logger.debug('completeNewPassword failure', err);\n                    dispatchAuthEvent(\n                        'completeNewPassword_failure',\n                        err,\n                        `${this.user} failed to complete the new password flow`\n                    );\n                    reject(err);\n                },\n                mfaRequired: (challengeName, challengeParam) => {\n                    logger.debug('signIn MFA required');\n                    user['challengeName'] = challengeName;\n                    user['challengeParam'] = challengeParam;\n                    resolve(user);\n                },\n                mfaSetup: (challengeName, challengeParam) => {\n                    logger.debug('signIn mfa setup', challengeName);\n                    user['challengeName'] = challengeName;\n                    user['challengeParam'] = challengeParam;\n                    resolve(user);\n                }\n            });\n        });\n    }\n\n    /**\n     * Send the answer to a custom challenge\n     * @param {CognitoUser} user - The CognitoUser object\n     * @param {String} challengeResponses - The confirmation code\n     */\n    public sendCustomChallengeAnswer(user: CognitoUser | any, challengeResponses: string): Promise<CognitoUser | any> {\n        if (!this.userPool) { return Promise.reject('No userPool'); }\n        if (!challengeResponses) { return Promise.reject('Challenge response cannot be empty'); }\n\n        const that = this;\n        return new Promise((resolve, reject) => {\n            user.sendCustomChallengeAnswer(challengeResponses, this.authCallbacks(user, resolve, reject));\n        });\n    }\n\n    /**\n     * Update an authenticated users' attributes\n     * @param {CognitoUser} - The currently logged in user object\n     * @return {Promise}\n     **/\n    public updateUserAttributes(user: CognitoUser | any, attributes: object): Promise<string> {\n        const attributeList: ICognitoUserAttributeData[] = [];\n        const that = this;\n        return new Promise((resolve, reject) => {\n            that.userSession(user).then(session => {\n                for (const key in attributes) {\n                    if (key !== 'sub' &&\n                        key.indexOf('_verified') < 0) {\n                        const attr: ICognitoUserAttributeData = {\n                            'Name': key,\n                            'Value': attributes[key]\n                        };\n                        attributeList.push(attr);\n                    }\n                }\n                user.updateAttributes(attributeList, (err, result) => {\n                    if (err) { return reject(err); } else { return resolve(result); }\n                });\n            });\n        });\n    }\n    /**\n     * Return user attributes\n     * @param {Object} user - The CognitoUser object\n     * @return - A promise resolves to user attributes if success\n     */\n    public userAttributes(user: CognitoUser | any): Promise<CognitoUserAttribute[]> {\n        return new Promise((resolve, reject) => {\n            this.userSession(user).then(session => {\n                user.getUserAttributes((err, attributes) => {\n                    if (err) { reject(err); } else { resolve(attributes); }\n                });\n            });\n        });\n    }\n\n    public verifiedContact(user: CognitoUser | any) {\n        const that = this;\n        return this.userAttributes(user)\n            .then(attributes => {\n                const attrs = that.attributesToObject(attributes);\n                const unverified = {};\n                const verified = {};\n                if (attrs['email']) {\n                    if (attrs['email_verified']) {\n                        verified['email'] = attrs['email'];\n                    } else {\n                        unverified['email'] = attrs['email'];\n                    }\n                }\n                if (attrs['phone_number']) {\n                    if (attrs['phone_number_verified']) {\n                        verified['phone_number'] = attrs['phone_number'];\n                    } else {\n                        unverified['phone_number'] = attrs['phone_number'];\n                    }\n                }\n                return {\n                    verified,\n                    unverified\n                };\n            });\n    }\n\n    /**\n     * Get current authenticated user\n     * @return - A promise resolves to current authenticated CognitoUser if success\n     */\n    public currentUserPoolUser(params?: CurrentUserOpts): Promise<CognitoUser | any> {\n        if (!this.userPool) { return Promise.reject('No userPool'); }\n        const that = this;\n        return new Promise((res, rej) => {\n            this._storageSync.then(() => {\n                const user = that.userPool.getCurrentUser();\n                if (!user) {\n                    logger.debug('Failed to get user from user pool');\n                    rej('No current user');\n                    return;\n                }\n\n                // refresh the session if the session expired.\n                user.getSession((err, session) => {\n                    if (err) {\n                        logger.debug('Failed to get the user session', err);\n                        rej(err);\n                        return;\n                    }\n\n                    // get user data from Cognito\n                    const bypassCache = params ? params.bypassCache : false;\n                    // validate the token's scope fisrt before calling this function\n                    const { scope = '' } = session.getAccessToken().decodePayload();\n                    if (scope.split(' ').includes(USER_ADMIN_SCOPE)) {\n                        user.getUserData(\n                            (err, data) => {\n                                if (err) {\n                                    logger.debug('getting user data failed', err);\n                                    // Make sure the user is still valid\n                                    if (err.message === 'User is disabled' || err.message === 'User does not exist.') {\n                                        rej(err);\n                                    } else {\n                                        // the error may also be thrown when lack of permissions to get user info etc\n                                        // in that case we just bypass the error\n                                        res(user);\n                                    }\n                                    return;\n                                }\n                                const preferredMFA = data.PreferredMfaSetting || 'NOMFA';\n                                const attributeList = [];\n\n                                for (let i = 0; i < data.UserAttributes.length; i++) {\n                                    const attribute = {\n                                        Name: data.UserAttributes[i].Name,\n                                        Value: data.UserAttributes[i].Value,\n                                    };\n                                    const userAttribute = new CognitoUserAttribute(attribute);\n                                    attributeList.push(userAttribute);\n                                }\n\n                                const attributes = that.attributesToObject(attributeList);\n                                Object.assign(user, { attributes, preferredMFA });\n                                return res(user);\n                            },\n                            { bypassCache }\n                        );\n                    } else {\n                        logger.debug(`Unable to get the user data because the ${USER_ADMIN_SCOPE} ` +\n                            `is not in the scopes of the access token`);\n                        return res(user);\n                    }\n                });\n            }).catch(e => {\n                logger.debug('Failed to sync cache info into memory', e);\n                return rej(e);\n            });\n        });\n    }\n\n    /**\n     * Get current authenticated user\n     * @param {CurrentUserOpts} - options for getting the current user\n     * @return - A promise resolves to current authenticated CognitoUser if success\n     */\n    public async currentAuthenticatedUser(params?: CurrentUserOpts): Promise<CognitoUser | any> {\n        logger.debug('getting current authenticted user');\n        let federatedUser = null;\n        try {\n            await this._storageSync;\n        } catch (e) {\n            logger.debug('Failed to sync cache info into memory', e);\n            throw e;\n        }\n\n        try {\n            federatedUser = JSON.parse(this._storage.getItem('aws-amplify-federatedInfo')).user;\n        } catch (e) {\n            logger.debug('cannot load federated user from auth storage');\n        }\n\n        if (federatedUser) {\n            this.user = federatedUser;\n            logger.debug('get current authenticated federated user', this.user);\n            return this.user;\n        } else {\n            logger.debug('get current authenticated userpool user');\n            let user = null;\n            try {\n                user = await this.currentUserPoolUser(params);\n            } catch (e) {\n                if (e === 'No userPool') {\n                    logger.error('Cannot get the current user because the user pool is missing. ' +\n                        'Please make sure the Auth module is configured with a valid Cognito User Pool ID');\n                }\n                logger.debug('The user is not authenticated by the error', e);\n                throw ('not authenticated');\n            }\n            this.user = user;\n            return this.user;\n        }\n    }\n\n    /**\n     * Get current user's session\n     * @return - A promise resolves to session object if success\n     */\n    public currentSession(): Promise<CognitoUserSession> {\n        const that = this;\n        logger.debug('Getting current session');\n        if (!this.userPool) { return Promise.reject('No userPool'); }\n\n        return new Promise((res, rej) => {\n            that.currentUserPoolUser().then(user => {\n                that.userSession(user).then(session => {\n                    res(session);\n                    return;\n                }).catch(e => {\n                    logger.debug('Failed to get the current session', e);\n                    rej(e);\n                    return;\n                });\n            }).catch(e => {\n                logger.debug('Failed to get the current user', e);\n                rej(e);\n                return;\n            });\n        });\n    }\n\n    /**\n     * Get the corresponding user session\n     * @param {Object} user - The CognitoUser object\n     * @return - A promise resolves to the session\n     */\n    public userSession(user): Promise<CognitoUserSession> {\n        if (!user) {\n            logger.debug('the user is null');\n            return Promise.reject('Failed to get the session because the user is empty');\n        }\n        return new Promise((resolve, reject) => {\n            logger.debug('Getting the session from this user:', user);\n            user.getSession((err, session) => {\n                if (err) {\n                    logger.debug('Failed to get the session from user', user);\n                    reject(err);\n                    return;\n                } else {\n                    logger.debug('Succeed to get the user session', session);\n                    resolve(session);\n                    return;\n                }\n            });\n        });\n    }\n\n    /**\n     * Get  authenticated credentials of current user.\n     * @return - A promise resolves to be current user's credentials\n     */\n    public async currentUserCredentials(): Promise<ICredentials> {\n        const that = this;\n        logger.debug('Getting current user credentials');\n\n        try {\n            await this._storageSync;\n        } catch (e) {\n            logger.debug('Failed to sync cache info into memory', e);\n            throw e;\n        }\n\n        // first to check whether there is federation info in the auth storage\n        let federatedInfo = null;\n        try {\n            federatedInfo = JSON.parse(this._storage.getItem('aws-amplify-federatedInfo'));\n        } catch (e) {\n            logger.debug('failed to get or parse item aws-amplify-federatedInfo', e);\n        }\n\n        if (federatedInfo) {\n            // refresh the jwt token here if necessary\n            return Credentials.refreshFederatedToken(federatedInfo);\n        } else {\n            return this.currentSession()\n                .then(session => {\n                    logger.debug('getting session success', session);\n                    return Credentials.set(session, 'session');\n                }).catch((error) => {\n                    logger.debug('getting session failed', error);\n                    return Credentials.set(null, 'guest');\n                });\n        }\n    }\n\n\n    public currentCredentials(): Promise<ICredentials> {\n        logger.debug('getting current credntials');\n        return Credentials.get();\n    }\n\n    /**\n     * Initiate an attribute confirmation request\n     * @param {Object} user - The CognitoUser\n     * @param {Object} attr - The attributes to be verified\n     * @return - A promise resolves to callback data if success\n     */\n    public verifyUserAttribute(user: CognitoUser | any, attr: string): Promise<void> {\n        return new Promise((resolve, reject) => {\n            user.getAttributeVerificationCode(attr, {\n                onSuccess() { return resolve(); },\n                onFailure(err) { return reject(err); }\n            });\n        });\n    }\n\n    /**\n     * Confirm an attribute using a confirmation code\n     * @param {Object} user - The CognitoUser\n     * @param {Object} attr - The attribute to be verified\n     * @param {String} code - The confirmation code\n     * @return - A promise resolves to callback data if success\n     */\n    public verifyUserAttributeSubmit(user: CognitoUser | any, attr: string, code: string): Promise<string> {\n        if (!code) { return Promise.reject('Code cannot be empty'); }\n\n        return new Promise((resolve, reject) => {\n            user.verifyAttribute(attr, code, {\n                onSuccess(data) {\n                    resolve(data);\n                    return;\n                },\n                onFailure(err) {\n                    reject(err);\n                    return;\n                }\n            });\n        });\n    }\n\n    public verifyCurrentUserAttribute(attr: string): Promise<void> {\n        const that = this;\n        return that.currentUserPoolUser()\n            .then(user => that.verifyUserAttribute(user, attr));\n    }\n\n    /**\n     * Confirm current user's attribute using a confirmation code\n     * @param {Object} attr - The attribute to be verified\n     * @param {String} code - The confirmation code\n     * @return - A promise resolves to callback data if success\n     */\n    verifyCurrentUserAttributeSubmit(attr: string, code: string): Promise<string> {\n        const that = this;\n        return that.currentUserPoolUser()\n            .then(user => that.verifyUserAttributeSubmit(user, attr, code));\n    }\n\n    private async cognitoIdentitySignOut(opts: SignOutOpts, user: CognitoUser | any) {\n        try {\n            await this._storageSync;\n        } catch (e) {\n            logger.debug('Failed to sync cache info into memory', e);\n            throw e;\n        }\n\n        const isSignedInHostedUI = this._oAuthHandler\n            && this._storage.getItem('amplify-signin-with-hostedUI') === 'true';\n\n        return new Promise((res, rej) => {\n            if (opts && opts.global) {\n                logger.debug('user global sign out', user);\n                // in order to use global signout\n                // we must validate the user as an authenticated user by using getSession\n                user.getSession((err, result) => {\n                    if (err) {\n                        logger.debug('failed to get the user session', err);\n                        return rej(err);\n                    }\n                    user.globalSignOut({\n                        onSuccess: (data) => {\n                            logger.debug('global sign out success');\n                            if (isSignedInHostedUI) {\n                                return this._oAuthHandler.signOut().then(() => res());\n                            } else {\n                                return res();\n                            }\n                        },\n                        onFailure: (err) => {\n                            logger.debug('global sign out failed', err);\n                            return rej(err);\n                        }\n                    });\n                });\n            } else {\n                logger.debug('user sign out', user);\n                user.signOut();\n                if (isSignedInHostedUI) {\n                    return this._oAuthHandler.signOut().then(() => res());\n                } else {\n                    return res();\n                }\n            }\n        });\n    }\n\n    /**\n     * Sign out method\n     * @\n     * @return - A promise resolved if success\n     */\n    public async signOut(opts?: SignOutOpts): Promise<any> {\n        try {\n            await this.cleanCachedItems();\n        } catch (e) {\n            logger.debug('failed to clear cached items');\n        }\n\n        if (this.userPool) {\n            const user = this.userPool.getCurrentUser();\n            if (user) {\n                await this.cognitoIdentitySignOut(opts, user);\n            } else {\n                logger.debug('no current Cognito user');\n            }\n        } else {\n            logger.debug('no Congito User pool');\n        }\n\n        /**\n         * Note for future refactor - no reliable way to get username with\n         * Cognito User Pools vs Identity when federating with Social Providers\n         * This is why we need a well structured session object that can be inspected\n         * and information passed back in the message below for Hub dispatch\n        */\n        dispatchAuthEvent(\n            'signOut',\n            this.user,\n            `A user has been signed out`\n        );\n        this.user = null;\n    }\n\n    private async cleanCachedItems() {\n        // clear cognito cached item\n        await Credentials.clear();\n    }\n\n    /**\n     * Change a password for an authenticated user\n     * @param {Object} user - The CognitoUser object\n     * @param {String} oldPassword - the current password\n     * @param {String} newPassword - the requested new password\n     * @return - A promise resolves if success\n     */\n    public changePassword(user: CognitoUser | any, oldPassword: string, newPassword: string): Promise<\"SUCCESS\"> {\n        return new Promise((resolve, reject) => {\n            this.userSession(user).then(session => {\n                user.changePassword(oldPassword, newPassword, (err, data) => {\n                    if (err) {\n                        logger.debug('change password failure', err);\n                        return reject(err);\n                    } else {\n                        return resolve(data);\n                    }\n                });\n            });\n        });\n    }\n\n    /**\n     * Initiate a forgot password request\n     * @param {String} username - the username to change password\n     * @return - A promise resolves if success\n     */\n    public forgotPassword(username: string): Promise<any> {\n        if (!this.userPool) { return Promise.reject('No userPool'); }\n        if (!username) { return Promise.reject('Username cannot be empty'); }\n\n        const user = this.createCognitoUser(username);\n        return new Promise((resolve, reject) => {\n            user.forgotPassword({\n                onSuccess: () => {\n                    resolve();\n                    return;\n                },\n                onFailure: err => {\n                    logger.debug('forgot password failure', err);\n                    reject(err);\n                    return;\n                },\n                inputVerificationCode: data => {\n                    resolve(data);\n                    return;\n                }\n            });\n        });\n    }\n\n    /**\n     * Confirm a new password using a confirmation Code\n     * @param {String} username - The username\n     * @param {String} code - The confirmation code\n     * @param {String} password - The new password\n     * @return - A promise that resolves if success\n     */\n    public forgotPasswordSubmit(\n        username: string,\n        code: string,\n        password: string\n    ): Promise<void> {\n        if (!this.userPool) { return Promise.reject('No userPool'); }\n        if (!username) { return Promise.reject('Username cannot be empty'); }\n        if (!code) { return Promise.reject('Code cannot be empty'); }\n        if (!password) { return Promise.reject('Password cannot be empty'); }\n\n        const user = this.createCognitoUser(username);\n        return new Promise((resolve, reject) => {\n            user.confirmPassword(code, password, {\n                onSuccess: () => {\n                    resolve();\n                    return;\n                },\n                onFailure: err => {\n                    reject(err);\n                    return;\n                }\n            });\n        });\n    }\n\n    /**\n     * Get user information\n     * @async\n     * @return {Object }- current User's information\n     */\n    public async currentUserInfo() {\n        const source = Credentials.getCredSource();\n\n        if (!source || source === 'aws' || source === 'userPool') {\n            const user = await this.currentUserPoolUser()\n                .catch(err => logger.debug(err));\n            if (!user) { return null; }\n\n            try {\n                const attributes = await this.userAttributes(user);\n                const userAttrs: object = this.attributesToObject(attributes);\n                let credentials = null;\n                try {\n                    credentials = await this.currentCredentials();\n                } catch (e) {\n                    logger.debug('Failed to retrieve credentials while getting current user info', e);\n                }\n\n\n                const info = {\n                    'id': credentials ? credentials.identityId : undefined,\n                    'username': user.getUsername(),\n                    'attributes': userAttrs\n                };\n                return info;\n            } catch (err) {\n                logger.debug('currentUserInfo error', err);\n                return {};\n            }\n        }\n\n        if (source === 'federated') {\n            const user = this.user;\n            return user ? user : {};\n        }\n    }\n\n\n    public async federatedSignIn(options?: FederatedSignInOptions):\n        Promise<ICredentials>;\n    public async federatedSignIn(\n        provider: LegacyProvider,\n        response: FederatedResponse,\n        user: FederatedUser\n    ): Promise<ICredentials>;\n    public async federatedSignIn(options?: FederatedSignInOptionsCustom):\n        Promise<ICredentials>;\n    public async federatedSignIn(\n        providerOrOptions: LegacyProvider | FederatedSignInOptions | FederatedSignInOptionsCustom,\n        response?: FederatedResponse,\n        user?: FederatedUser\n    ): Promise<ICredentials> {\n\n\n        if (!this._config.identityPoolId && !this._config.userPoolId) {\n            throw new Error(`Federation requires either a User Pool or Identity Pool in config`);\n        }\n\n        // Ensure backwards compatability\n        if (typeof providerOrOptions === 'undefined') {\n            if (this._config.identityPoolId && !this._config.userPoolId) {\n                throw new Error(`Federation with Identity Pools requires tokens passed as arguments`);\n            }\n        }\n\n        if (isFederatedSignInOptions(providerOrOptions)\n            || isFederatedSignInOptionsCustom(providerOrOptions)\n            || typeof providerOrOptions === 'undefined') {\n\n            const options = providerOrOptions || { provider: CognitoHostedUIIdentityProvider.Cognito };\n            const provider = isFederatedSignInOptions(options)\n                ? options.provider\n                : (options as FederatedSignInOptionsCustom).customProvider;\n\n            if (this._config.userPoolId) {\n                const client_id = isCognitoHostedOpts(this._config.oauth)\n                    ? this._config.userPoolWebClientId\n                    : this._config.oauth.clientID;\n                /*Note: Invenstigate automatically adding trailing slash */\n                const redirect_uri = isCognitoHostedOpts(this._config.oauth)\n                    ? this._config.oauth.redirectSignIn\n                    : this._config.oauth.redirectUri;\n\n                this._oAuthHandler.oauthSignIn(\n                    this._config.oauth.responseType,\n                    this._config.oauth.domain,\n                    redirect_uri,\n                    client_id,\n                    provider);\n\n            }\n        } else {\n\n            const provider = providerOrOptions;\n            // To check if the user is already logged in\n            try {\n                const loggedInUser = await this.currentAuthenticatedUser();\n                logger.warn(`There is already a signed in user: ${loggedInUser} in your app.\n                You should not call Auth.federatedSignIn method again as it may cause unexpected behavior.`);\n            } catch (e) { }\n\n            const { token, identity_id, expires_at } = response;\n            // Because Credentials.set would update the user info with identity id\n            // So we need to retrieve the user again.\n            const credentials = await Credentials.set(\n                { provider, token, identity_id, user, expires_at },\n                'federation'\n            );\n            const currentUser = await this.currentAuthenticatedUser();\n            dispatchAuthEvent(\n                'signIn',\n                currentUser,\n                `A user ${currentUser.username} has been signed in`\n            );\n            logger.debug('federated sign in credentials', credentials);\n            return credentials;\n        }\n    }\n\n    /**\n     * Used to complete the OAuth flow with or without the Cognito Hosted UI\n     * @param {String} URL - optional parameter for customers to pass in the response URL\n     */\n    private async _handleAuthResponse(URL?: string) {\n\n        if (!this._config.userPoolId){\n            throw new Error(`OAuth responses require a User Pool defined in config`);\n        }\n\n        const currentUrl = URL || (JS.browserOrNode().isBrowser ? window.location.href : null);\n\n        const hasCodeOrError = !!(parse(currentUrl).query || '')\n            .split('&')\n            .map(entry => entry.split('='))\n            .find(([k]) => k === 'code' || k === 'error');\n\n        const hasTokenOrError = !!(parse(currentUrl).hash || '#')\n            .substr(1)\n            .split('&')\n            .map(entry => entry.split('='))\n            .find(([k]) => k === 'access_token' || k === 'error');\n\n\n        if (hasCodeOrError || hasTokenOrError) {\n            try {\n\n                const { accessToken, idToken, refreshToken } = await this._oAuthHandler.handleAuthResponse(currentUrl);\n                const session = new CognitoUserSession({\n                    IdToken: new CognitoIdToken({ IdToken: idToken }),\n                    RefreshToken: new CognitoRefreshToken({ RefreshToken: refreshToken }),\n                    AccessToken: new CognitoAccessToken({ AccessToken: accessToken })\n                });\n\n                let credentials;\n                // Get AWS Credentials & store if Identity Pool is defined\n                if (this._config.identityPoolId) {\n                    credentials = await Credentials.set(session, 'session');\n                    logger.debug('AWS credentials', credentials);\n                }\n\n                /*The following is to create a user for the Cognito Identity SDK to store the tokens\n                  When we remove this SDK later that logic will have to be centralized in our new version*/\n                //#region\n                const currentUser = this.createCognitoUser(session.getIdToken().decodePayload()['cognito:username']);\n                dispatchAuthEvent(\n                    'signIn',\n                    currentUser,\n                    `A user ${currentUser.getUsername()} has been signed in`\n                );\n                dispatchAuthEvent(\n                    'cognitoHostedUI',\n                    currentUser,\n                    `A user ${currentUser.getUsername()} has been signed in via Cognito Hosted UI`\n                );\n\n                // This calls cacheTokens() in Cognito SDK\n                currentUser.setSignInUserSession(session);\n                //#endregion\n\n                if (window && typeof window.history !== 'undefined') {\n                    window.history.replaceState({}, null, (this._config.oauth as AwsCognitoOAuthOpts).redirectSignIn);\n                }\n\n                return credentials;\n            } catch (err) {\n                logger.debug(\"Error in cognito hosted auth response\", err);\n                dispatchAuthEvent(\n                    'signIn_failure',\n                    err,\n                    `The OAuth response flow failed`\n                );\n                dispatchAuthEvent(\n                    'cognitoHostedUI_failure',\n                    err,\n                    `A failure occurred when returning to the Cognito Hosted UI`\n                );\n                throw err;\n            }\n        }\n\n    }\n\n    /**\n     * Compact version of credentials\n     * @param {Object} credentials\n     * @return {Object} - Credentials\n     */\n    public essentialCredentials(credentials): ICredentials {\n        return {\n            accessKeyId: credentials.accessKeyId,\n            sessionToken: credentials.sessionToken,\n            secretAccessKey: credentials.secretAccessKey,\n            identityId: credentials.identityId,\n            authenticated: credentials.authenticated\n        };\n    }\n\n    private attributesToObject(attributes) {\n        const obj = {};\n        if (attributes) {\n            attributes.map(attribute => {\n                if (attribute.Value === 'true') {\n                    obj[attribute.Name] = true;\n                } else if (attribute.Value === 'false') {\n                    obj[attribute.Name] = false;\n                } else {\n                    obj[attribute.Name] = attribute.Value;\n                }\n            });\n        }\n        return obj;\n    }\n\n    private createCognitoUser(username: string): CognitoUser {\n        const userData: ICognitoUserData = {\n            Username: username,\n            Pool: this.userPool,\n        };\n        userData.Storage = this._storage;\n\n        const { authenticationFlowType } = this._config;\n\n        const user = new CognitoUser(userData);\n        if (authenticationFlowType) {\n            user.setAuthenticationFlowType(authenticationFlowType);\n        }\n        return user;\n    }\n}\n"]}},"error":null,"hash":"76aa901ec64c0832331d9b2ce7c6184f","cacheData":{"env":{}}}